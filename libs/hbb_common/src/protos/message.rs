// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `message.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.EncodedVideoFrame)
pub struct EncodedVideoFrame {
    // message fields
    // @@protoc_insertion_point(field:hbb.EncodedVideoFrame.data)
    pub data: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.EncodedVideoFrame.key)
    pub key: bool,
    // @@protoc_insertion_point(field:hbb.EncodedVideoFrame.pts)
    pub pts: i64,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.EncodedVideoFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EncodedVideoFrame {
    fn default() -> &'a EncodedVideoFrame {
        <EncodedVideoFrame as ::protobuf::Message>::default_instance()
    }
}

impl EncodedVideoFrame {
    pub fn new() -> EncodedVideoFrame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &EncodedVideoFrame| { &m.data },
            |m: &mut EncodedVideoFrame| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &EncodedVideoFrame| { &m.key },
            |m: &mut EncodedVideoFrame| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pts",
            |m: &EncodedVideoFrame| { &m.pts },
            |m: &mut EncodedVideoFrame| { &mut m.pts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EncodedVideoFrame>(
            "EncodedVideoFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EncodedVideoFrame {
    const NAME: &'static str = "EncodedVideoFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_tokio_bytes()?;
                },
                16 => {
                    self.key = is.read_bool()?;
                },
                24 => {
                    self.pts = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.key != false {
            my_size += 1 + 1;
        }
        if self.pts != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.pts);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.key != false {
            os.write_bool(2, self.key)?;
        }
        if self.pts != 0 {
            os.write_int64(3, self.pts)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EncodedVideoFrame {
        EncodedVideoFrame::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.key = false;
        self.pts = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EncodedVideoFrame {
        static instance: EncodedVideoFrame = EncodedVideoFrame {
            data: ::bytes::Bytes::new(),
            key: false,
            pts: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EncodedVideoFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EncodedVideoFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EncodedVideoFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncodedVideoFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.EncodedVideoFrames)
pub struct EncodedVideoFrames {
    // message fields
    // @@protoc_insertion_point(field:hbb.EncodedVideoFrames.frames)
    pub frames: ::std::vec::Vec<EncodedVideoFrame>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.EncodedVideoFrames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EncodedVideoFrames {
    fn default() -> &'a EncodedVideoFrames {
        <EncodedVideoFrames as ::protobuf::Message>::default_instance()
    }
}

impl EncodedVideoFrames {
    pub fn new() -> EncodedVideoFrames {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "frames",
            |m: &EncodedVideoFrames| { &m.frames },
            |m: &mut EncodedVideoFrames| { &mut m.frames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EncodedVideoFrames>(
            "EncodedVideoFrames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EncodedVideoFrames {
    const NAME: &'static str = "EncodedVideoFrames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.frames.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.frames {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EncodedVideoFrames {
        EncodedVideoFrames::new()
    }

    fn clear(&mut self) {
        self.frames.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EncodedVideoFrames {
        static instance: EncodedVideoFrames = EncodedVideoFrames {
            frames: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EncodedVideoFrames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EncodedVideoFrames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EncodedVideoFrames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncodedVideoFrames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.RGB)
pub struct RGB {
    // message fields
    // @@protoc_insertion_point(field:hbb.RGB.compress)
    pub compress: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.RGB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RGB {
    fn default() -> &'a RGB {
        <RGB as ::protobuf::Message>::default_instance()
    }
}

impl RGB {
    pub fn new() -> RGB {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &RGB| { &m.compress },
            |m: &mut RGB| { &mut m.compress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RGB>(
            "RGB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RGB {
    const NAME: &'static str = "RGB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.compress = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RGB {
        RGB::new()
    }

    fn clear(&mut self) {
        self.compress = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RGB {
        static instance: RGB = RGB {
            compress: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RGB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RGB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RGB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RGB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.YUV)
pub struct YUV {
    // message fields
    // @@protoc_insertion_point(field:hbb.YUV.compress)
    pub compress: bool,
    // @@protoc_insertion_point(field:hbb.YUV.stride)
    pub stride: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.YUV.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a YUV {
    fn default() -> &'a YUV {
        <YUV as ::protobuf::Message>::default_instance()
    }
}

impl YUV {
    pub fn new() -> YUV {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &YUV| { &m.compress },
            |m: &mut YUV| { &mut m.compress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stride",
            |m: &YUV| { &m.stride },
            |m: &mut YUV| { &mut m.stride },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<YUV>(
            "YUV",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for YUV {
    const NAME: &'static str = "YUV";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.compress = is.read_bool()?;
                },
                16 => {
                    self.stride = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 1 + 1;
        }
        if self.stride != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.stride);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        if self.stride != 0 {
            os.write_int32(2, self.stride)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> YUV {
        YUV::new()
    }

    fn clear(&mut self) {
        self.compress = false;
        self.stride = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static YUV {
        static instance: YUV = YUV {
            compress: false,
            stride: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for YUV {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("YUV").unwrap()).clone()
    }
}

impl ::std::fmt::Display for YUV {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for YUV {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.VideoFrame)
pub struct VideoFrame {
    // message fields
    // @@protoc_insertion_point(field:hbb.VideoFrame.timestamp)
    pub timestamp: i64,
    // message oneof groups
    pub union: ::std::option::Option<video_frame::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.VideoFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoFrame {
    fn default() -> &'a VideoFrame {
        <VideoFrame as ::protobuf::Message>::default_instance()
    }
}

impl VideoFrame {
    pub fn new() -> VideoFrame {
        ::std::default::Default::default()
    }

    // .hbb.EncodedVideoFrames vp9s = 6;

    pub fn vp9s(&self) -> &EncodedVideoFrames {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp9s(ref v)) => v,
            _ => <EncodedVideoFrames as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vp9s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_vp9s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp9s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vp9s(&mut self, v: EncodedVideoFrames) {
        self.union = ::std::option::Option::Some(video_frame::Union::Vp9s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vp9s(&mut self) -> &mut EncodedVideoFrames {
        if let ::std::option::Option::Some(video_frame::Union::Vp9s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::Vp9s(EncodedVideoFrames::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Vp9s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vp9s(&mut self) -> EncodedVideoFrames {
        if self.has_vp9s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::Vp9s(v)) => v,
                _ => panic!(),
            }
        } else {
            EncodedVideoFrames::new()
        }
    }

    // .hbb.RGB rgb = 7;

    pub fn rgb(&self) -> &RGB {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Rgb(ref v)) => v,
            _ => <RGB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_rgb(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_rgb(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Rgb(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rgb(&mut self, v: RGB) {
        self.union = ::std::option::Option::Some(video_frame::Union::Rgb(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rgb(&mut self) -> &mut RGB {
        if let ::std::option::Option::Some(video_frame::Union::Rgb(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::Rgb(RGB::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Rgb(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rgb(&mut self) -> RGB {
        if self.has_rgb() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::Rgb(v)) => v,
                _ => panic!(),
            }
        } else {
            RGB::new()
        }
    }

    // .hbb.YUV yuv = 8;

    pub fn yuv(&self) -> &YUV {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Yuv(ref v)) => v,
            _ => <YUV as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_yuv(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_yuv(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Yuv(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_yuv(&mut self, v: YUV) {
        self.union = ::std::option::Option::Some(video_frame::Union::Yuv(v))
    }

    // Mutable pointer to the field.
    pub fn mut_yuv(&mut self) -> &mut YUV {
        if let ::std::option::Option::Some(video_frame::Union::Yuv(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::Yuv(YUV::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::Yuv(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_yuv(&mut self) -> YUV {
        if self.has_yuv() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::Yuv(v)) => v,
                _ => panic!(),
            }
        } else {
            YUV::new()
        }
    }

    // .hbb.EncodedVideoFrames h264s = 10;

    pub fn h264s(&self) -> &EncodedVideoFrames {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H264s(ref v)) => v,
            _ => <EncodedVideoFrames as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_h264s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_h264s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H264s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_h264s(&mut self, v: EncodedVideoFrames) {
        self.union = ::std::option::Option::Some(video_frame::Union::H264s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_h264s(&mut self) -> &mut EncodedVideoFrames {
        if let ::std::option::Option::Some(video_frame::Union::H264s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::H264s(EncodedVideoFrames::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H264s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_h264s(&mut self) -> EncodedVideoFrames {
        if self.has_h264s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::H264s(v)) => v,
                _ => panic!(),
            }
        } else {
            EncodedVideoFrames::new()
        }
    }

    // .hbb.EncodedVideoFrames h265s = 11;

    pub fn h265s(&self) -> &EncodedVideoFrames {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H265s(ref v)) => v,
            _ => <EncodedVideoFrames as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_h265s(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_h265s(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H265s(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_h265s(&mut self, v: EncodedVideoFrames) {
        self.union = ::std::option::Option::Some(video_frame::Union::H265s(v))
    }

    // Mutable pointer to the field.
    pub fn mut_h265s(&mut self) -> &mut EncodedVideoFrames {
        if let ::std::option::Option::Some(video_frame::Union::H265s(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(video_frame::Union::H265s(EncodedVideoFrames::new()));
        }
        match self.union {
            ::std::option::Option::Some(video_frame::Union::H265s(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_h265s(&mut self) -> EncodedVideoFrames {
        if self.has_h265s() {
            match self.union.take() {
                ::std::option::Option::Some(video_frame::Union::H265s(v)) => v,
                _ => panic!(),
            }
        } else {
            EncodedVideoFrames::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncodedVideoFrames>(
            "vp9s",
            VideoFrame::has_vp9s,
            VideoFrame::vp9s,
            VideoFrame::mut_vp9s,
            VideoFrame::set_vp9s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RGB>(
            "rgb",
            VideoFrame::has_rgb,
            VideoFrame::rgb,
            VideoFrame::mut_rgb,
            VideoFrame::set_rgb,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, YUV>(
            "yuv",
            VideoFrame::has_yuv,
            VideoFrame::yuv,
            VideoFrame::mut_yuv,
            VideoFrame::set_yuv,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncodedVideoFrames>(
            "h264s",
            VideoFrame::has_h264s,
            VideoFrame::h264s,
            VideoFrame::mut_h264s,
            VideoFrame::set_h264s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncodedVideoFrames>(
            "h265s",
            VideoFrame::has_h265s,
            VideoFrame::h265s,
            VideoFrame::mut_h265s,
            VideoFrame::set_h265s,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &VideoFrame| { &m.timestamp },
            |m: &mut VideoFrame| { &mut m.timestamp },
        ));
        oneofs.push(video_frame::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoFrame>(
            "VideoFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoFrame {
    const NAME: &'static str = "VideoFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::Vp9s(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::Rgb(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::Yuv(is.read_message()?));
                },
                82 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::H264s(is.read_message()?));
                },
                90 => {
                    self.union = ::std::option::Option::Some(video_frame::Union::H265s(is.read_message()?));
                },
                72 => {
                    self.timestamp = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.timestamp);
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &video_frame::Union::Vp9s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::Rgb(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::Yuv(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::H264s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &video_frame::Union::H265s(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestamp != 0 {
            os.write_int64(9, self.timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &video_frame::Union::Vp9s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &video_frame::Union::Rgb(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &video_frame::Union::Yuv(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &video_frame::Union::H264s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &video_frame::Union::H265s(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoFrame {
        VideoFrame::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoFrame {
        static instance: VideoFrame = VideoFrame {
            timestamp: 0,
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VideoFrame`
pub mod video_frame {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.VideoFrame.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.vp9s)
        Vp9s(super::EncodedVideoFrames),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.rgb)
        Rgb(super::RGB),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.yuv)
        Yuv(super::YUV),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.h264s)
        H264s(super::EncodedVideoFrames),
        // @@protoc_insertion_point(oneof_field:hbb.VideoFrame.h265s)
        H265s(super::EncodedVideoFrames),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::VideoFrame as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.IdPk)
pub struct IdPk {
    // message fields
    // @@protoc_insertion_point(field:hbb.IdPk.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.IdPk.pk)
    pub pk: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.IdPk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdPk {
    fn default() -> &'a IdPk {
        <IdPk as ::protobuf::Message>::default_instance()
    }
}

impl IdPk {
    pub fn new() -> IdPk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &IdPk| { &m.id },
            |m: &mut IdPk| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pk",
            |m: &IdPk| { &m.pk },
            |m: &mut IdPk| { &mut m.pk },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdPk>(
            "IdPk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdPk {
    const NAME: &'static str = "IdPk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.pk = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.pk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.pk.is_empty() {
            os.write_bytes(2, &self.pk)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdPk {
        IdPk::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.pk.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdPk {
        static instance: IdPk = IdPk {
            id: ::std::string::String::new(),
            pk: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdPk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdPk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdPk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdPk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.DisplayInfo)
pub struct DisplayInfo {
    // message fields
    // @@protoc_insertion_point(field:hbb.DisplayInfo.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.y)
    pub y: i32,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.width)
    pub width: i32,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.height)
    pub height: i32,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.online)
    pub online: bool,
    // @@protoc_insertion_point(field:hbb.DisplayInfo.cursor_embedded)
    pub cursor_embedded: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.DisplayInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisplayInfo {
    fn default() -> &'a DisplayInfo {
        <DisplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl DisplayInfo {
    pub fn new() -> DisplayInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &DisplayInfo| { &m.x },
            |m: &mut DisplayInfo| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &DisplayInfo| { &m.y },
            |m: &mut DisplayInfo| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &DisplayInfo| { &m.width },
            |m: &mut DisplayInfo| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &DisplayInfo| { &m.height },
            |m: &mut DisplayInfo| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DisplayInfo| { &m.name },
            |m: &mut DisplayInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "online",
            |m: &DisplayInfo| { &m.online },
            |m: &mut DisplayInfo| { &mut m.online },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor_embedded",
            |m: &DisplayInfo| { &m.cursor_embedded },
            |m: &mut DisplayInfo| { &mut m.cursor_embedded },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisplayInfo>(
            "DisplayInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisplayInfo {
    const NAME: &'static str = "DisplayInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_sint32()?;
                },
                16 => {
                    self.y = is.read_sint32()?;
                },
                24 => {
                    self.width = is.read_int32()?;
                },
                32 => {
                    self.height = is.read_int32()?;
                },
                42 => {
                    self.name = is.read_string()?;
                },
                48 => {
                    self.online = is.read_bool()?;
                },
                56 => {
                    self.cursor_embedded = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::sint32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.y);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.height);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if self.online != false {
            my_size += 1 + 1;
        }
        if self.cursor_embedded != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_sint32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(2, self.y)?;
        }
        if self.width != 0 {
            os.write_int32(3, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(4, self.height)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if self.online != false {
            os.write_bool(6, self.online)?;
        }
        if self.cursor_embedded != false {
            os.write_bool(7, self.cursor_embedded)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisplayInfo {
        DisplayInfo::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.width = 0;
        self.height = 0;
        self.name.clear();
        self.online = false;
        self.cursor_embedded = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisplayInfo {
        static instance: DisplayInfo = DisplayInfo {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            name: ::std::string::String::new(),
            online: false,
            cursor_embedded: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisplayInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisplayInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.PortForward)
pub struct PortForward {
    // message fields
    // @@protoc_insertion_point(field:hbb.PortForward.host)
    pub host: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PortForward.port)
    pub port: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PortForward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PortForward {
    fn default() -> &'a PortForward {
        <PortForward as ::protobuf::Message>::default_instance()
    }
}

impl PortForward {
    pub fn new() -> PortForward {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &PortForward| { &m.host },
            |m: &mut PortForward| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &PortForward| { &m.port },
            |m: &mut PortForward| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PortForward>(
            "PortForward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PortForward {
    const NAME: &'static str = "PortForward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = is.read_string()?;
                },
                16 => {
                    self.port = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PortForward {
        PortForward::new()
    }

    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PortForward {
        static instance: PortForward = PortForward {
            host: ::std::string::String::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PortForward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PortForward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PortForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortForward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransfer)
pub struct FileTransfer {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransfer.dir)
    pub dir: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileTransfer.show_hidden)
    pub show_hidden: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransfer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransfer {
    fn default() -> &'a FileTransfer {
        <FileTransfer as ::protobuf::Message>::default_instance()
    }
}

impl FileTransfer {
    pub fn new() -> FileTransfer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dir",
            |m: &FileTransfer| { &m.dir },
            |m: &mut FileTransfer| { &mut m.dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show_hidden",
            |m: &FileTransfer| { &m.show_hidden },
            |m: &mut FileTransfer| { &mut m.show_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransfer>(
            "FileTransfer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransfer {
    const NAME: &'static str = "FileTransfer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dir = is.read_string()?;
                },
                16 => {
                    self.show_hidden = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dir);
        }
        if self.show_hidden != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dir.is_empty() {
            os.write_string(1, &self.dir)?;
        }
        if self.show_hidden != false {
            os.write_bool(2, self.show_hidden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransfer {
        FileTransfer::new()
    }

    fn clear(&mut self) {
        self.dir.clear();
        self.show_hidden = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransfer {
        static instance: FileTransfer = FileTransfer {
            dir: ::std::string::String::new(),
            show_hidden: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransfer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransfer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransfer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.LoginRequest)
pub struct LoginRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.LoginRequest.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.LoginRequest.password)
    pub password: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.LoginRequest.my_id)
    pub my_id: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.LoginRequest.my_name)
    pub my_name: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.LoginRequest.option)
    pub option: ::protobuf::MessageField<OptionMessage>,
    // @@protoc_insertion_point(field:hbb.LoginRequest.video_ack_required)
    pub video_ack_required: bool,
    // @@protoc_insertion_point(field:hbb.LoginRequest.session_id)
    pub session_id: u64,
    // @@protoc_insertion_point(field:hbb.LoginRequest.version)
    pub version: ::std::string::String,
    // message oneof groups
    pub union: ::std::option::Option<login_request::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.LoginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginRequest {
    fn default() -> &'a LoginRequest {
        <LoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoginRequest {
    pub fn new() -> LoginRequest {
        ::std::default::Default::default()
    }

    // .hbb.FileTransfer file_transfer = 7;

    pub fn file_transfer(&self) -> &FileTransfer {
        match self.union {
            ::std::option::Option::Some(login_request::Union::FileTransfer(ref v)) => v,
            _ => <FileTransfer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_transfer(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_transfer(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_request::Union::FileTransfer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_transfer(&mut self, v: FileTransfer) {
        self.union = ::std::option::Option::Some(login_request::Union::FileTransfer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_transfer(&mut self) -> &mut FileTransfer {
        if let ::std::option::Option::Some(login_request::Union::FileTransfer(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_request::Union::FileTransfer(FileTransfer::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_request::Union::FileTransfer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_transfer(&mut self) -> FileTransfer {
        if self.has_file_transfer() {
            match self.union.take() {
                ::std::option::Option::Some(login_request::Union::FileTransfer(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransfer::new()
        }
    }

    // .hbb.PortForward port_forward = 8;

    pub fn port_forward(&self) -> &PortForward {
        match self.union {
            ::std::option::Option::Some(login_request::Union::PortForward(ref v)) => v,
            _ => <PortForward as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_port_forward(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_port_forward(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_request::Union::PortForward(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_port_forward(&mut self, v: PortForward) {
        self.union = ::std::option::Option::Some(login_request::Union::PortForward(v))
    }

    // Mutable pointer to the field.
    pub fn mut_port_forward(&mut self) -> &mut PortForward {
        if let ::std::option::Option::Some(login_request::Union::PortForward(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_request::Union::PortForward(PortForward::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_request::Union::PortForward(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_port_forward(&mut self) -> PortForward {
        if self.has_port_forward() {
            match self.union.take() {
                ::std::option::Option::Some(login_request::Union::PortForward(v)) => v,
                _ => panic!(),
            }
        } else {
            PortForward::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &LoginRequest| { &m.username },
            |m: &mut LoginRequest| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &LoginRequest| { &m.password },
            |m: &mut LoginRequest| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "my_id",
            |m: &LoginRequest| { &m.my_id },
            |m: &mut LoginRequest| { &mut m.my_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "my_name",
            |m: &LoginRequest| { &m.my_name },
            |m: &mut LoginRequest| { &mut m.my_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OptionMessage>(
            "option",
            |m: &LoginRequest| { &m.option },
            |m: &mut LoginRequest| { &mut m.option },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransfer>(
            "file_transfer",
            LoginRequest::has_file_transfer,
            LoginRequest::file_transfer,
            LoginRequest::mut_file_transfer,
            LoginRequest::set_file_transfer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PortForward>(
            "port_forward",
            LoginRequest::has_port_forward,
            LoginRequest::port_forward,
            LoginRequest::mut_port_forward,
            LoginRequest::set_port_forward,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "video_ack_required",
            |m: &LoginRequest| { &m.video_ack_required },
            |m: &mut LoginRequest| { &mut m.video_ack_required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_id",
            |m: &LoginRequest| { &m.session_id },
            |m: &mut LoginRequest| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &LoginRequest| { &m.version },
            |m: &mut LoginRequest| { &mut m.version },
        ));
        oneofs.push(login_request::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginRequest>(
            "LoginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginRequest {
    const NAME: &'static str = "LoginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                18 => {
                    self.password = is.read_tokio_bytes()?;
                },
                34 => {
                    self.my_id = is.read_string()?;
                },
                42 => {
                    self.my_name = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.option)?;
                },
                58 => {
                    self.union = ::std::option::Option::Some(login_request::Union::FileTransfer(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(login_request::Union::PortForward(is.read_message()?));
                },
                72 => {
                    self.video_ack_required = is.read_bool()?;
                },
                80 => {
                    self.session_id = is.read_uint64()?;
                },
                90 => {
                    self.version = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.password);
        }
        if !self.my_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.my_id);
        }
        if !self.my_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.my_name);
        }
        if let Some(v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.video_ack_required != false {
            my_size += 1 + 1;
        }
        if self.session_id != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.session_id);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.version);
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_request::Union::FileTransfer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &login_request::Union::PortForward(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_bytes(2, &self.password)?;
        }
        if !self.my_id.is_empty() {
            os.write_string(4, &self.my_id)?;
        }
        if !self.my_name.is_empty() {
            os.write_string(5, &self.my_name)?;
        }
        if let Some(v) = self.option.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.video_ack_required != false {
            os.write_bool(9, self.video_ack_required)?;
        }
        if self.session_id != 0 {
            os.write_uint64(10, self.session_id)?;
        }
        if !self.version.is_empty() {
            os.write_string(11, &self.version)?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_request::Union::FileTransfer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &login_request::Union::PortForward(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginRequest {
        LoginRequest::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.my_id.clear();
        self.my_name.clear();
        self.option.clear();
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.video_ack_required = false;
        self.session_id = 0;
        self.version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginRequest {
        static instance: LoginRequest = LoginRequest {
            username: ::std::string::String::new(),
            password: ::bytes::Bytes::new(),
            my_id: ::std::string::String::new(),
            my_name: ::std::string::String::new(),
            option: ::protobuf::MessageField::none(),
            video_ack_required: false,
            session_id: 0,
            version: ::std::string::String::new(),
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginRequest`
pub mod login_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.LoginRequest.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.LoginRequest.file_transfer)
        FileTransfer(super::FileTransfer),
        // @@protoc_insertion_point(oneof_field:hbb.LoginRequest.port_forward)
        PortForward(super::PortForward),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LoginRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.ChatMessage)
pub struct ChatMessage {
    // message fields
    // @@protoc_insertion_point(field:hbb.ChatMessage.text)
    pub text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatMessage {
    fn default() -> &'a ChatMessage {
        <ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl ChatMessage {
    pub fn new() -> ChatMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &ChatMessage| { &m.text },
            |m: &mut ChatMessage| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessage>(
            "ChatMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatMessage {
    const NAME: &'static str = "ChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatMessage {
        ChatMessage::new()
    }

    fn clear(&mut self) {
        self.text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatMessage {
        static instance: ChatMessage = ChatMessage {
            text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.Features)
pub struct Features {
    // message fields
    // @@protoc_insertion_point(field:hbb.Features.privacy_mode)
    pub privacy_mode: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Features.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Features {
    fn default() -> &'a Features {
        <Features as ::protobuf::Message>::default_instance()
    }
}

impl Features {
    pub fn new() -> Features {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "privacy_mode",
            |m: &Features| { &m.privacy_mode },
            |m: &mut Features| { &mut m.privacy_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Features>(
            "Features",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Features {
    const NAME: &'static str = "Features";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.privacy_mode = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.privacy_mode != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.privacy_mode != false {
            os.write_bool(1, self.privacy_mode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Features {
        Features::new()
    }

    fn clear(&mut self) {
        self.privacy_mode = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Features {
        static instance: Features = Features {
            privacy_mode: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Features {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Features").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Features {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Features {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.SupportedEncoding)
pub struct SupportedEncoding {
    // message fields
    // @@protoc_insertion_point(field:hbb.SupportedEncoding.h264)
    pub h264: bool,
    // @@protoc_insertion_point(field:hbb.SupportedEncoding.h265)
    pub h265: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SupportedEncoding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SupportedEncoding {
    fn default() -> &'a SupportedEncoding {
        <SupportedEncoding as ::protobuf::Message>::default_instance()
    }
}

impl SupportedEncoding {
    pub fn new() -> SupportedEncoding {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "h264",
            |m: &SupportedEncoding| { &m.h264 },
            |m: &mut SupportedEncoding| { &mut m.h264 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "h265",
            |m: &SupportedEncoding| { &m.h265 },
            |m: &mut SupportedEncoding| { &mut m.h265 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SupportedEncoding>(
            "SupportedEncoding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SupportedEncoding {
    const NAME: &'static str = "SupportedEncoding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.h264 = is.read_bool()?;
                },
                16 => {
                    self.h265 = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.h264 != false {
            my_size += 1 + 1;
        }
        if self.h265 != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.h264 != false {
            os.write_bool(1, self.h264)?;
        }
        if self.h265 != false {
            os.write_bool(2, self.h265)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SupportedEncoding {
        SupportedEncoding::new()
    }

    fn clear(&mut self) {
        self.h264 = false;
        self.h265 = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SupportedEncoding {
        static instance: SupportedEncoding = SupportedEncoding {
            h264: false,
            h265: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SupportedEncoding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SupportedEncoding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SupportedEncoding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupportedEncoding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.PeerInfo)
pub struct PeerInfo {
    // message fields
    // @@protoc_insertion_point(field:hbb.PeerInfo.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.hostname)
    pub hostname: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.platform)
    pub platform: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.displays)
    pub displays: ::std::vec::Vec<DisplayInfo>,
    // @@protoc_insertion_point(field:hbb.PeerInfo.current_display)
    pub current_display: i32,
    // @@protoc_insertion_point(field:hbb.PeerInfo.sas_enabled)
    pub sas_enabled: bool,
    // @@protoc_insertion_point(field:hbb.PeerInfo.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.PeerInfo.conn_id)
    pub conn_id: i32,
    // @@protoc_insertion_point(field:hbb.PeerInfo.features)
    pub features: ::protobuf::MessageField<Features>,
    // @@protoc_insertion_point(field:hbb.PeerInfo.encoding)
    pub encoding: ::protobuf::MessageField<SupportedEncoding>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PeerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerInfo {
    fn default() -> &'a PeerInfo {
        <PeerInfo as ::protobuf::Message>::default_instance()
    }
}

impl PeerInfo {
    pub fn new() -> PeerInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &PeerInfo| { &m.username },
            |m: &mut PeerInfo| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hostname",
            |m: &PeerInfo| { &m.hostname },
            |m: &mut PeerInfo| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform",
            |m: &PeerInfo| { &m.platform },
            |m: &mut PeerInfo| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "displays",
            |m: &PeerInfo| { &m.displays },
            |m: &mut PeerInfo| { &mut m.displays },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_display",
            |m: &PeerInfo| { &m.current_display },
            |m: &mut PeerInfo| { &mut m.current_display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sas_enabled",
            |m: &PeerInfo| { &m.sas_enabled },
            |m: &mut PeerInfo| { &mut m.sas_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &PeerInfo| { &m.version },
            |m: &mut PeerInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conn_id",
            |m: &PeerInfo| { &m.conn_id },
            |m: &mut PeerInfo| { &mut m.conn_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Features>(
            "features",
            |m: &PeerInfo| { &m.features },
            |m: &mut PeerInfo| { &mut m.features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SupportedEncoding>(
            "encoding",
            |m: &PeerInfo| { &m.encoding },
            |m: &mut PeerInfo| { &mut m.encoding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerInfo>(
            "PeerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerInfo {
    const NAME: &'static str = "PeerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                18 => {
                    self.hostname = is.read_string()?;
                },
                26 => {
                    self.platform = is.read_string()?;
                },
                34 => {
                    self.displays.push(is.read_message()?);
                },
                40 => {
                    self.current_display = is.read_int32()?;
                },
                48 => {
                    self.sas_enabled = is.read_bool()?;
                },
                58 => {
                    self.version = is.read_string()?;
                },
                64 => {
                    self.conn_id = is.read_int32()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.features)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.encoding)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hostname);
        }
        if !self.platform.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.platform);
        }
        for value in &self.displays {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.current_display != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.current_display);
        }
        if self.sas_enabled != false {
            my_size += 1 + 1;
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version);
        }
        if self.conn_id != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.conn_id);
        }
        if let Some(v) = self.features.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.encoding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.hostname.is_empty() {
            os.write_string(2, &self.hostname)?;
        }
        if !self.platform.is_empty() {
            os.write_string(3, &self.platform)?;
        }
        for v in &self.displays {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.current_display != 0 {
            os.write_int32(5, self.current_display)?;
        }
        if self.sas_enabled != false {
            os.write_bool(6, self.sas_enabled)?;
        }
        if !self.version.is_empty() {
            os.write_string(7, &self.version)?;
        }
        if self.conn_id != 0 {
            os.write_int32(8, self.conn_id)?;
        }
        if let Some(v) = self.features.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.encoding.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerInfo {
        PeerInfo::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.hostname.clear();
        self.platform.clear();
        self.displays.clear();
        self.current_display = 0;
        self.sas_enabled = false;
        self.version.clear();
        self.conn_id = 0;
        self.features.clear();
        self.encoding.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerInfo {
        static instance: PeerInfo = PeerInfo {
            username: ::std::string::String::new(),
            hostname: ::std::string::String::new(),
            platform: ::std::string::String::new(),
            displays: ::std::vec::Vec::new(),
            current_display: 0,
            sas_enabled: false,
            version: ::std::string::String::new(),
            conn_id: 0,
            features: ::protobuf::MessageField::none(),
            encoding: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.LoginResponse)
pub struct LoginResponse {
    // message oneof groups
    pub union: ::std::option::Option<login_response::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.LoginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginResponse {
    fn default() -> &'a LoginResponse {
        <LoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoginResponse {
    pub fn new() -> LoginResponse {
        ::std::default::Default::default()
    }

    // string error = 1;

    pub fn error(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(login_response::Union::Error(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_response::Union::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(login_response::Union::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(login_response::Union::Error(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_response::Union::Error(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_response::Union::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        if self.has_error() {
            match self.union.take() {
                ::std::option::Option::Some(login_response::Union::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .hbb.PeerInfo peer_info = 2;

    pub fn peer_info(&self) -> &PeerInfo {
        match self.union {
            ::std::option::Option::Some(login_response::Union::PeerInfo(ref v)) => v,
            _ => <PeerInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_peer_info(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_peer_info(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(login_response::Union::PeerInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_peer_info(&mut self, v: PeerInfo) {
        self.union = ::std::option::Option::Some(login_response::Union::PeerInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_peer_info(&mut self) -> &mut PeerInfo {
        if let ::std::option::Option::Some(login_response::Union::PeerInfo(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(login_response::Union::PeerInfo(PeerInfo::new()));
        }
        match self.union {
            ::std::option::Option::Some(login_response::Union::PeerInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_peer_info(&mut self) -> PeerInfo {
        if self.has_peer_info() {
            match self.union.take() {
                ::std::option::Option::Some(login_response::Union::PeerInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            PeerInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "error",
            LoginResponse::has_error,
            LoginResponse::error,
            LoginResponse::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PeerInfo>(
            "peer_info",
            LoginResponse::has_peer_info,
            LoginResponse::peer_info,
            LoginResponse::mut_peer_info,
            LoginResponse::set_peer_info,
        ));
        oneofs.push(login_response::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginResponse>(
            "LoginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginResponse {
    const NAME: &'static str = "LoginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(login_response::Union::Error(is.read_string()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(login_response::Union::PeerInfo(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_response::Union::Error(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &login_response::Union::PeerInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &login_response::Union::Error(ref v) => {
                    os.write_string(1, v)?;
                },
                &login_response::Union::PeerInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginResponse {
        LoginResponse::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginResponse {
        static instance: LoginResponse = LoginResponse {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginResponse`
pub mod login_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.LoginResponse.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.LoginResponse.error)
        Error(::std::string::String),
        // @@protoc_insertion_point(oneof_field:hbb.LoginResponse.peer_info)
        PeerInfo(super::PeerInfo),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LoginResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.MouseEvent)
pub struct MouseEvent {
    // message fields
    // @@protoc_insertion_point(field:hbb.MouseEvent.mask)
    pub mask: i32,
    // @@protoc_insertion_point(field:hbb.MouseEvent.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.MouseEvent.y)
    pub y: i32,
    // @@protoc_insertion_point(field:hbb.MouseEvent.modifiers)
    pub modifiers: ::std::vec::Vec<::protobuf::EnumOrUnknown<ControlKey>>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.MouseEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MouseEvent {
    fn default() -> &'a MouseEvent {
        <MouseEvent as ::protobuf::Message>::default_instance()
    }
}

impl MouseEvent {
    pub fn new() -> MouseEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mask",
            |m: &MouseEvent| { &m.mask },
            |m: &mut MouseEvent| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &MouseEvent| { &m.x },
            |m: &mut MouseEvent| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &MouseEvent| { &m.y },
            |m: &mut MouseEvent| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &MouseEvent| { &m.modifiers },
            |m: &mut MouseEvent| { &mut m.modifiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MouseEvent>(
            "MouseEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MouseEvent {
    const NAME: &'static str = "MouseEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mask = is.read_int32()?;
                },
                16 => {
                    self.x = is.read_sint32()?;
                },
                24 => {
                    self.y = is.read_sint32()?;
                },
                32 => {
                    self.modifiers.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.modifiers)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mask != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.mask);
        }
        if self.x != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.y);
        }
        for value in &self.modifiers {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mask != 0 {
            os.write_int32(1, self.mask)?;
        }
        if self.x != 0 {
            os.write_sint32(2, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(3, self.y)?;
        }
        for v in &self.modifiers {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MouseEvent {
        MouseEvent::new()
    }

    fn clear(&mut self) {
        self.mask = 0;
        self.x = 0;
        self.y = 0;
        self.modifiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MouseEvent {
        static instance: MouseEvent = MouseEvent {
            mask: 0,
            x: 0,
            y: 0,
            modifiers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MouseEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MouseEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MouseEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MouseEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.KeyEvent)
pub struct KeyEvent {
    // message fields
    // @@protoc_insertion_point(field:hbb.KeyEvent.down)
    pub down: bool,
    // @@protoc_insertion_point(field:hbb.KeyEvent.press)
    pub press: bool,
    // @@protoc_insertion_point(field:hbb.KeyEvent.modifiers)
    pub modifiers: ::std::vec::Vec<::protobuf::EnumOrUnknown<ControlKey>>,
    // @@protoc_insertion_point(field:hbb.KeyEvent.mode)
    pub mode: ::protobuf::EnumOrUnknown<KeyboardMode>,
    // message oneof groups
    pub union: ::std::option::Option<key_event::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.KeyEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyEvent {
    fn default() -> &'a KeyEvent {
        <KeyEvent as ::protobuf::Message>::default_instance()
    }
}

impl KeyEvent {
    pub fn new() -> KeyEvent {
        ::std::default::Default::default()
    }

    // .hbb.ControlKey control_key = 3;

    pub fn control_key(&self) -> ControlKey {
        match self.union {
            ::std::option::Option::Some(key_event::Union::ControlKey(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => ControlKey::Unknown,
        }
    }

    pub fn clear_control_key(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_control_key(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::ControlKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_control_key(&mut self, v: ControlKey) {
        self.union = ::std::option::Option::Some(key_event::Union::ControlKey(::protobuf::EnumOrUnknown::new(v)))
    }

    // uint32 chr = 4;

    pub fn chr(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Chr(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_chr(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_chr(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Chr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chr(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(key_event::Union::Chr(v))
    }

    // uint32 unicode = 5;

    pub fn unicode(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Unicode(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_unicode(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_unicode(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Unicode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unicode(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(key_event::Union::Unicode(v))
    }

    // string seq = 6;

    pub fn seq(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Seq(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_seq(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(key_event::Union::Seq(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(key_event::Union::Seq(v))
    }

    // Mutable pointer to the field.
    pub fn mut_seq(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(key_event::Union::Seq(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(key_event::Union::Seq(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(key_event::Union::Seq(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_seq(&mut self) -> ::std::string::String {
        if self.has_seq() {
            match self.union.take() {
                ::std::option::Option::Some(key_event::Union::Seq(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "down",
            |m: &KeyEvent| { &m.down },
            |m: &mut KeyEvent| { &mut m.down },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "press",
            |m: &KeyEvent| { &m.press },
            |m: &mut KeyEvent| { &mut m.press },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "control_key",
            |message: &KeyEvent| match &message.union {
                ::std::option::Option::Some(key_event::Union::ControlKey(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut KeyEvent, e: ::protobuf::EnumOrUnknown<ControlKey>| {
                message.union = ::std::option::Option::Some(key_event::Union::ControlKey(e));
            },
            ControlKey::Unknown,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "chr",
            KeyEvent::has_chr,
            KeyEvent::chr,
            KeyEvent::set_chr,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "unicode",
            KeyEvent::has_unicode,
            KeyEvent::unicode,
            KeyEvent::set_unicode,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "seq",
            KeyEvent::has_seq,
            KeyEvent::seq,
            KeyEvent::set_seq,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modifiers",
            |m: &KeyEvent| { &m.modifiers },
            |m: &mut KeyEvent| { &mut m.modifiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &KeyEvent| { &m.mode },
            |m: &mut KeyEvent| { &mut m.mode },
        ));
        oneofs.push(key_event::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyEvent>(
            "KeyEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyEvent {
    const NAME: &'static str = "KeyEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.down = is.read_bool()?;
                },
                16 => {
                    self.press = is.read_bool()?;
                },
                24 => {
                    self.union = ::std::option::Option::Some(key_event::Union::ControlKey(is.read_enum_or_unknown()?));
                },
                32 => {
                    self.union = ::std::option::Option::Some(key_event::Union::Chr(is.read_uint32()?));
                },
                40 => {
                    self.union = ::std::option::Option::Some(key_event::Union::Unicode(is.read_uint32()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(key_event::Union::Seq(is.read_string()?));
                },
                64 => {
                    self.modifiers.push(is.read_enum_or_unknown()?);
                },
                66 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.modifiers)?
                },
                72 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.down != false {
            my_size += 1 + 1;
        }
        if self.press != false {
            my_size += 1 + 1;
        }
        for value in &self.modifiers {
            my_size += ::protobuf::rt::int32_size(8, value.value());
        };
        if self.mode != ::protobuf::EnumOrUnknown::new(KeyboardMode::Legacy) {
            my_size += ::protobuf::rt::int32_size(9, self.mode.value());
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &key_event::Union::ControlKey(v) => {
                    my_size += ::protobuf::rt::int32_size(3, v.value());
                },
                &key_event::Union::Chr(v) => {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                },
                &key_event::Union::Unicode(v) => {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                },
                &key_event::Union::Seq(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.down != false {
            os.write_bool(1, self.down)?;
        }
        if self.press != false {
            os.write_bool(2, self.press)?;
        }
        for v in &self.modifiers {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if self.mode != ::protobuf::EnumOrUnknown::new(KeyboardMode::Legacy) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &key_event::Union::ControlKey(v) => {
                    os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &key_event::Union::Chr(v) => {
                    os.write_uint32(4, v)?;
                },
                &key_event::Union::Unicode(v) => {
                    os.write_uint32(5, v)?;
                },
                &key_event::Union::Seq(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyEvent {
        KeyEvent::new()
    }

    fn clear(&mut self) {
        self.down = false;
        self.press = false;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.modifiers.clear();
        self.mode = ::protobuf::EnumOrUnknown::new(KeyboardMode::Legacy);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyEvent {
        static instance: KeyEvent = KeyEvent {
            down: false,
            press: false,
            modifiers: ::std::vec::Vec::new(),
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `KeyEvent`
pub mod key_event {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.KeyEvent.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.control_key)
        ControlKey(::protobuf::EnumOrUnknown<super::ControlKey>),
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.chr)
        Chr(u32),
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.unicode)
        Unicode(u32),
        // @@protoc_insertion_point(oneof_field:hbb.KeyEvent.seq)
        Seq(::std::string::String),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::KeyEvent as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CursorData)
pub struct CursorData {
    // message fields
    // @@protoc_insertion_point(field:hbb.CursorData.id)
    pub id: u64,
    // @@protoc_insertion_point(field:hbb.CursorData.hotx)
    pub hotx: i32,
    // @@protoc_insertion_point(field:hbb.CursorData.hoty)
    pub hoty: i32,
    // @@protoc_insertion_point(field:hbb.CursorData.width)
    pub width: i32,
    // @@protoc_insertion_point(field:hbb.CursorData.height)
    pub height: i32,
    // @@protoc_insertion_point(field:hbb.CursorData.colors)
    pub colors: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CursorData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CursorData {
    fn default() -> &'a CursorData {
        <CursorData as ::protobuf::Message>::default_instance()
    }
}

impl CursorData {
    pub fn new() -> CursorData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CursorData| { &m.id },
            |m: &mut CursorData| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hotx",
            |m: &CursorData| { &m.hotx },
            |m: &mut CursorData| { &mut m.hotx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hoty",
            |m: &CursorData| { &m.hoty },
            |m: &mut CursorData| { &mut m.hoty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &CursorData| { &m.width },
            |m: &mut CursorData| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &CursorData| { &m.height },
            |m: &mut CursorData| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "colors",
            |m: &CursorData| { &m.colors },
            |m: &mut CursorData| { &mut m.colors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CursorData>(
            "CursorData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CursorData {
    const NAME: &'static str = "CursorData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                16 => {
                    self.hotx = is.read_sint32()?;
                },
                24 => {
                    self.hoty = is.read_sint32()?;
                },
                32 => {
                    self.width = is.read_int32()?;
                },
                40 => {
                    self.height = is.read_int32()?;
                },
                50 => {
                    self.colors = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if self.hotx != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.hotx);
        }
        if self.hoty != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.hoty);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.height);
        }
        if !self.colors.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.colors);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.hotx != 0 {
            os.write_sint32(2, self.hotx)?;
        }
        if self.hoty != 0 {
            os.write_sint32(3, self.hoty)?;
        }
        if self.width != 0 {
            os.write_int32(4, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(5, self.height)?;
        }
        if !self.colors.is_empty() {
            os.write_bytes(6, &self.colors)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CursorData {
        CursorData::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.hotx = 0;
        self.hoty = 0;
        self.width = 0;
        self.height = 0;
        self.colors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CursorData {
        static instance: CursorData = CursorData {
            id: 0,
            hotx: 0,
            hoty: 0,
            width: 0,
            height: 0,
            colors: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CursorData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CursorData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CursorData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CursorData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CursorPosition)
pub struct CursorPosition {
    // message fields
    // @@protoc_insertion_point(field:hbb.CursorPosition.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.CursorPosition.y)
    pub y: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CursorPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CursorPosition {
    fn default() -> &'a CursorPosition {
        <CursorPosition as ::protobuf::Message>::default_instance()
    }
}

impl CursorPosition {
    pub fn new() -> CursorPosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &CursorPosition| { &m.x },
            |m: &mut CursorPosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &CursorPosition| { &m.y },
            |m: &mut CursorPosition| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CursorPosition>(
            "CursorPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CursorPosition {
    const NAME: &'static str = "CursorPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_sint32()?;
                },
                16 => {
                    self.y = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::sint32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.y);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_sint32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CursorPosition {
        CursorPosition::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CursorPosition {
        static instance: CursorPosition = CursorPosition {
            x: 0,
            y: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CursorPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CursorPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CursorPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CursorPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.Hash)
pub struct Hash {
    // message fields
    // @@protoc_insertion_point(field:hbb.Hash.salt)
    pub salt: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.Hash.challenge)
    pub challenge: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Hash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Hash {
    fn default() -> &'a Hash {
        <Hash as ::protobuf::Message>::default_instance()
    }
}

impl Hash {
    pub fn new() -> Hash {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "salt",
            |m: &Hash| { &m.salt },
            |m: &mut Hash| { &mut m.salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "challenge",
            |m: &Hash| { &m.challenge },
            |m: &mut Hash| { &mut m.challenge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hash>(
            "Hash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Hash {
    const NAME: &'static str = "Hash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.salt = is.read_string()?;
                },
                18 => {
                    self.challenge = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.salt.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.salt);
        }
        if !self.challenge.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.challenge);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.salt.is_empty() {
            os.write_string(1, &self.salt)?;
        }
        if !self.challenge.is_empty() {
            os.write_string(2, &self.challenge)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Hash {
        Hash::new()
    }

    fn clear(&mut self) {
        self.salt.clear();
        self.challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Hash {
        static instance: Hash = Hash {
            salt: ::std::string::String::new(),
            challenge: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Hash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Hash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Hash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.Clipboard)
pub struct Clipboard {
    // message fields
    // @@protoc_insertion_point(field:hbb.Clipboard.compress)
    pub compress: bool,
    // @@protoc_insertion_point(field:hbb.Clipboard.content)
    pub content: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Clipboard.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Clipboard {
    fn default() -> &'a Clipboard {
        <Clipboard as ::protobuf::Message>::default_instance()
    }
}

impl Clipboard {
    pub fn new() -> Clipboard {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &Clipboard| { &m.compress },
            |m: &mut Clipboard| { &mut m.compress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &Clipboard| { &m.content },
            |m: &mut Clipboard| { &mut m.content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Clipboard>(
            "Clipboard",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Clipboard {
    const NAME: &'static str = "Clipboard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.compress = is.read_bool()?;
                },
                18 => {
                    self.content = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 1 + 1;
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(2, &self.content)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Clipboard {
        Clipboard::new()
    }

    fn clear(&mut self) {
        self.compress = false;
        self.content.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Clipboard {
        static instance: Clipboard = Clipboard {
            compress: false,
            content: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Clipboard {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Clipboard").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Clipboard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Clipboard {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileEntry)
pub struct FileEntry {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileEntry.entry_type)
    pub entry_type: ::protobuf::EnumOrUnknown<FileType>,
    // @@protoc_insertion_point(field:hbb.FileEntry.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileEntry.is_hidden)
    pub is_hidden: bool,
    // @@protoc_insertion_point(field:hbb.FileEntry.size)
    pub size: u64,
    // @@protoc_insertion_point(field:hbb.FileEntry.modified_time)
    pub modified_time: u64,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileEntry {
    fn default() -> &'a FileEntry {
        <FileEntry as ::protobuf::Message>::default_instance()
    }
}

impl FileEntry {
    pub fn new() -> FileEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entry_type",
            |m: &FileEntry| { &m.entry_type },
            |m: &mut FileEntry| { &mut m.entry_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FileEntry| { &m.name },
            |m: &mut FileEntry| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_hidden",
            |m: &FileEntry| { &m.is_hidden },
            |m: &mut FileEntry| { &mut m.is_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &FileEntry| { &m.size },
            |m: &mut FileEntry| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modified_time",
            |m: &FileEntry| { &m.modified_time },
            |m: &mut FileEntry| { &mut m.modified_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileEntry>(
            "FileEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileEntry {
    const NAME: &'static str = "FileEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entry_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.is_hidden = is.read_bool()?;
                },
                32 => {
                    self.size = is.read_uint64()?;
                },
                40 => {
                    self.modified_time = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.entry_type != ::protobuf::EnumOrUnknown::new(FileType::Dir) {
            my_size += ::protobuf::rt::int32_size(1, self.entry_type.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.is_hidden != false {
            my_size += 1 + 1;
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.size);
        }
        if self.modified_time != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.modified_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.entry_type != ::protobuf::EnumOrUnknown::new(FileType::Dir) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.entry_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.is_hidden != false {
            os.write_bool(3, self.is_hidden)?;
        }
        if self.size != 0 {
            os.write_uint64(4, self.size)?;
        }
        if self.modified_time != 0 {
            os.write_uint64(5, self.modified_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileEntry {
        FileEntry::new()
    }

    fn clear(&mut self) {
        self.entry_type = ::protobuf::EnumOrUnknown::new(FileType::Dir);
        self.name.clear();
        self.is_hidden = false;
        self.size = 0;
        self.modified_time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileEntry {
        static instance: FileEntry = FileEntry {
            entry_type: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            is_hidden: false,
            size: 0,
            modified_time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileDirectory)
pub struct FileDirectory {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileDirectory.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileDirectory.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileDirectory.entries)
    pub entries: ::std::vec::Vec<FileEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileDirectory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDirectory {
    fn default() -> &'a FileDirectory {
        <FileDirectory as ::protobuf::Message>::default_instance()
    }
}

impl FileDirectory {
    pub fn new() -> FileDirectory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileDirectory| { &m.id },
            |m: &mut FileDirectory| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileDirectory| { &m.path },
            |m: &mut FileDirectory| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &FileDirectory| { &m.entries },
            |m: &mut FileDirectory| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDirectory>(
            "FileDirectory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileDirectory {
    const NAME: &'static str = "FileDirectory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                26 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDirectory {
        FileDirectory::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDirectory {
        static instance: FileDirectory = FileDirectory {
            id: 0,
            path: ::std::string::String::new(),
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileDirectory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDirectory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDirectory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDirectory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.ReadDir)
pub struct ReadDir {
    // message fields
    // @@protoc_insertion_point(field:hbb.ReadDir.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.ReadDir.include_hidden)
    pub include_hidden: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ReadDir.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadDir {
    fn default() -> &'a ReadDir {
        <ReadDir as ::protobuf::Message>::default_instance()
    }
}

impl ReadDir {
    pub fn new() -> ReadDir {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ReadDir| { &m.path },
            |m: &mut ReadDir| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &ReadDir| { &m.include_hidden },
            |m: &mut ReadDir| { &mut m.include_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadDir>(
            "ReadDir",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadDir {
    const NAME: &'static str = "ReadDir";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                16 => {
                    self.include_hidden = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.include_hidden != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(2, self.include_hidden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadDir {
        ReadDir::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.include_hidden = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadDir {
        static instance: ReadDir = ReadDir {
            path: ::std::string::String::new(),
            include_hidden: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadDir {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadDir").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadDir {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.ReadAllFiles)
pub struct ReadAllFiles {
    // message fields
    // @@protoc_insertion_point(field:hbb.ReadAllFiles.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.ReadAllFiles.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.ReadAllFiles.include_hidden)
    pub include_hidden: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ReadAllFiles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadAllFiles {
    fn default() -> &'a ReadAllFiles {
        <ReadAllFiles as ::protobuf::Message>::default_instance()
    }
}

impl ReadAllFiles {
    pub fn new() -> ReadAllFiles {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ReadAllFiles| { &m.id },
            |m: &mut ReadAllFiles| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ReadAllFiles| { &m.path },
            |m: &mut ReadAllFiles| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &ReadAllFiles| { &m.include_hidden },
            |m: &mut ReadAllFiles| { &mut m.include_hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadAllFiles>(
            "ReadAllFiles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadAllFiles {
    const NAME: &'static str = "ReadAllFiles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.include_hidden = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.include_hidden != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(3, self.include_hidden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadAllFiles {
        ReadAllFiles::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.include_hidden = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadAllFiles {
        static instance: ReadAllFiles = ReadAllFiles {
            id: 0,
            path: ::std::string::String::new(),
            include_hidden: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadAllFiles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadAllFiles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadAllFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadAllFiles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileAction)
pub struct FileAction {
    // message oneof groups
    pub union: ::std::option::Option<file_action::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileAction {
    fn default() -> &'a FileAction {
        <FileAction as ::protobuf::Message>::default_instance()
    }
}

impl FileAction {
    pub fn new() -> FileAction {
        ::std::default::Default::default()
    }

    // .hbb.ReadDir read_dir = 1;

    pub fn read_dir(&self) -> &ReadDir {
        match self.union {
            ::std::option::Option::Some(file_action::Union::ReadDir(ref v)) => v,
            _ => <ReadDir as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_read_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_read_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::ReadDir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_dir(&mut self, v: ReadDir) {
        self.union = ::std::option::Option::Some(file_action::Union::ReadDir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_dir(&mut self) -> &mut ReadDir {
        if let ::std::option::Option::Some(file_action::Union::ReadDir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::ReadDir(ReadDir::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::ReadDir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_dir(&mut self) -> ReadDir {
        if self.has_read_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::ReadDir(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadDir::new()
        }
    }

    // .hbb.FileTransferSendRequest send = 2;

    pub fn send(&self) -> &FileTransferSendRequest {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Send(ref v)) => v,
            _ => <FileTransferSendRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_send(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Send(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send(&mut self, v: FileTransferSendRequest) {
        self.union = ::std::option::Option::Some(file_action::Union::Send(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send(&mut self) -> &mut FileTransferSendRequest {
        if let ::std::option::Option::Some(file_action::Union::Send(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::Send(FileTransferSendRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::Send(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send(&mut self) -> FileTransferSendRequest {
        if self.has_send() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::Send(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferSendRequest::new()
        }
    }

    // .hbb.FileTransferReceiveRequest receive = 3;

    pub fn receive(&self) -> &FileTransferReceiveRequest {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Receive(ref v)) => v,
            _ => <FileTransferReceiveRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_receive(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_receive(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Receive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_receive(&mut self, v: FileTransferReceiveRequest) {
        self.union = ::std::option::Option::Some(file_action::Union::Receive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_receive(&mut self) -> &mut FileTransferReceiveRequest {
        if let ::std::option::Option::Some(file_action::Union::Receive(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::Receive(FileTransferReceiveRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::Receive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_receive(&mut self) -> FileTransferReceiveRequest {
        if self.has_receive() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::Receive(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferReceiveRequest::new()
        }
    }

    // .hbb.FileDirCreate create = 4;

    pub fn create(&self) -> &FileDirCreate {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Create(ref v)) => v,
            _ => <FileDirCreate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_create(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Create(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: FileDirCreate) {
        self.union = ::std::option::Option::Some(file_action::Union::Create(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create(&mut self) -> &mut FileDirCreate {
        if let ::std::option::Option::Some(file_action::Union::Create(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::Create(FileDirCreate::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::Create(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create(&mut self) -> FileDirCreate {
        if self.has_create() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::Create(v)) => v,
                _ => panic!(),
            }
        } else {
            FileDirCreate::new()
        }
    }

    // .hbb.FileRemoveDir remove_dir = 5;

    pub fn remove_dir(&self) -> &FileRemoveDir {
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveDir(ref v)) => v,
            _ => <FileRemoveDir as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_remove_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveDir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_dir(&mut self, v: FileRemoveDir) {
        self.union = ::std::option::Option::Some(file_action::Union::RemoveDir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_dir(&mut self) -> &mut FileRemoveDir {
        if let ::std::option::Option::Some(file_action::Union::RemoveDir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::RemoveDir(FileRemoveDir::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveDir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_dir(&mut self) -> FileRemoveDir {
        if self.has_remove_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::RemoveDir(v)) => v,
                _ => panic!(),
            }
        } else {
            FileRemoveDir::new()
        }
    }

    // .hbb.FileRemoveFile remove_file = 6;

    pub fn remove_file(&self) -> &FileRemoveFile {
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveFile(ref v)) => v,
            _ => <FileRemoveFile as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_remove_file(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_remove_file(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveFile(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_file(&mut self, v: FileRemoveFile) {
        self.union = ::std::option::Option::Some(file_action::Union::RemoveFile(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove_file(&mut self) -> &mut FileRemoveFile {
        if let ::std::option::Option::Some(file_action::Union::RemoveFile(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::RemoveFile(FileRemoveFile::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::RemoveFile(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove_file(&mut self) -> FileRemoveFile {
        if self.has_remove_file() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::RemoveFile(v)) => v,
                _ => panic!(),
            }
        } else {
            FileRemoveFile::new()
        }
    }

    // .hbb.ReadAllFiles all_files = 7;

    pub fn all_files(&self) -> &ReadAllFiles {
        match self.union {
            ::std::option::Option::Some(file_action::Union::AllFiles(ref v)) => v,
            _ => <ReadAllFiles as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_all_files(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_all_files(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::AllFiles(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_all_files(&mut self, v: ReadAllFiles) {
        self.union = ::std::option::Option::Some(file_action::Union::AllFiles(v))
    }

    // Mutable pointer to the field.
    pub fn mut_all_files(&mut self) -> &mut ReadAllFiles {
        if let ::std::option::Option::Some(file_action::Union::AllFiles(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::AllFiles(ReadAllFiles::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::AllFiles(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_all_files(&mut self) -> ReadAllFiles {
        if self.has_all_files() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::AllFiles(v)) => v,
                _ => panic!(),
            }
        } else {
            ReadAllFiles::new()
        }
    }

    // .hbb.FileTransferCancel cancel = 8;

    pub fn cancel(&self) -> &FileTransferCancel {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Cancel(ref v)) => v,
            _ => <FileTransferCancel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cancel(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cancel(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::Cancel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cancel(&mut self, v: FileTransferCancel) {
        self.union = ::std::option::Option::Some(file_action::Union::Cancel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cancel(&mut self) -> &mut FileTransferCancel {
        if let ::std::option::Option::Some(file_action::Union::Cancel(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::Cancel(FileTransferCancel::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::Cancel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cancel(&mut self) -> FileTransferCancel {
        if self.has_cancel() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::Cancel(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferCancel::new()
        }
    }

    // .hbb.FileTransferSendConfirmRequest send_confirm = 9;

    pub fn send_confirm(&self) -> &FileTransferSendConfirmRequest {
        match self.union {
            ::std::option::Option::Some(file_action::Union::SendConfirm(ref v)) => v,
            _ => <FileTransferSendConfirmRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_send_confirm(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_send_confirm(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_action::Union::SendConfirm(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send_confirm(&mut self, v: FileTransferSendConfirmRequest) {
        self.union = ::std::option::Option::Some(file_action::Union::SendConfirm(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send_confirm(&mut self) -> &mut FileTransferSendConfirmRequest {
        if let ::std::option::Option::Some(file_action::Union::SendConfirm(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_action::Union::SendConfirm(FileTransferSendConfirmRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_action::Union::SendConfirm(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send_confirm(&mut self) -> FileTransferSendConfirmRequest {
        if self.has_send_confirm() {
            match self.union.take() {
                ::std::option::Option::Some(file_action::Union::SendConfirm(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferSendConfirmRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReadDir>(
            "read_dir",
            FileAction::has_read_dir,
            FileAction::read_dir,
            FileAction::mut_read_dir,
            FileAction::set_read_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferSendRequest>(
            "send",
            FileAction::has_send,
            FileAction::send,
            FileAction::mut_send,
            FileAction::set_send,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferReceiveRequest>(
            "receive",
            FileAction::has_receive,
            FileAction::receive,
            FileAction::mut_receive,
            FileAction::set_receive,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileDirCreate>(
            "create",
            FileAction::has_create,
            FileAction::create,
            FileAction::mut_create,
            FileAction::set_create,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileRemoveDir>(
            "remove_dir",
            FileAction::has_remove_dir,
            FileAction::remove_dir,
            FileAction::mut_remove_dir,
            FileAction::set_remove_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileRemoveFile>(
            "remove_file",
            FileAction::has_remove_file,
            FileAction::remove_file,
            FileAction::mut_remove_file,
            FileAction::set_remove_file,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReadAllFiles>(
            "all_files",
            FileAction::has_all_files,
            FileAction::all_files,
            FileAction::mut_all_files,
            FileAction::set_all_files,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferCancel>(
            "cancel",
            FileAction::has_cancel,
            FileAction::cancel,
            FileAction::mut_cancel,
            FileAction::set_cancel,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferSendConfirmRequest>(
            "send_confirm",
            FileAction::has_send_confirm,
            FileAction::send_confirm,
            FileAction::mut_send_confirm,
            FileAction::set_send_confirm,
        ));
        oneofs.push(file_action::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileAction>(
            "FileAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileAction {
    const NAME: &'static str = "FileAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(file_action::Union::ReadDir(is.read_message()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(file_action::Union::Send(is.read_message()?));
                },
                26 => {
                    self.union = ::std::option::Option::Some(file_action::Union::Receive(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(file_action::Union::Create(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(file_action::Union::RemoveDir(is.read_message()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(file_action::Union::RemoveFile(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(file_action::Union::AllFiles(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(file_action::Union::Cancel(is.read_message()?));
                },
                74 => {
                    self.union = ::std::option::Option::Some(file_action::Union::SendConfirm(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_action::Union::ReadDir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::Send(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::Receive(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::Create(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::RemoveDir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::RemoveFile(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::AllFiles(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::Cancel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_action::Union::SendConfirm(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_action::Union::ReadDir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &file_action::Union::Send(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &file_action::Union::Receive(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &file_action::Union::Create(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &file_action::Union::RemoveDir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &file_action::Union::RemoveFile(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &file_action::Union::AllFiles(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &file_action::Union::Cancel(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &file_action::Union::SendConfirm(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileAction {
        FileAction::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileAction {
        static instance: FileAction = FileAction {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileAction`
pub mod file_action {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.FileAction.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.read_dir)
        ReadDir(super::ReadDir),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.send)
        Send(super::FileTransferSendRequest),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.receive)
        Receive(super::FileTransferReceiveRequest),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.create)
        Create(super::FileDirCreate),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.remove_dir)
        RemoveDir(super::FileRemoveDir),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.remove_file)
        RemoveFile(super::FileRemoveFile),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.all_files)
        AllFiles(super::ReadAllFiles),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.cancel)
        Cancel(super::FileTransferCancel),
        // @@protoc_insertion_point(oneof_field:hbb.FileAction.send_confirm)
        SendConfirm(super::FileTransferSendConfirmRequest),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FileAction as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransferCancel)
pub struct FileTransferCancel {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferCancel.id)
    pub id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferCancel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferCancel {
    fn default() -> &'a FileTransferCancel {
        <FileTransferCancel as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferCancel {
    pub fn new() -> FileTransferCancel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferCancel| { &m.id },
            |m: &mut FileTransferCancel| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferCancel>(
            "FileTransferCancel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferCancel {
    const NAME: &'static str = "FileTransferCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferCancel {
        FileTransferCancel::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferCancel {
        static instance: FileTransferCancel = FileTransferCancel {
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferCancel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferCancel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferCancel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileResponse)
pub struct FileResponse {
    // message oneof groups
    pub union: ::std::option::Option<file_response::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileResponse {
    fn default() -> &'a FileResponse {
        <FileResponse as ::protobuf::Message>::default_instance()
    }
}

impl FileResponse {
    pub fn new() -> FileResponse {
        ::std::default::Default::default()
    }

    // .hbb.FileDirectory dir = 1;

    pub fn dir(&self) -> &FileDirectory {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Dir(ref v)) => v,
            _ => <FileDirectory as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dir(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_dir(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Dir(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dir(&mut self, v: FileDirectory) {
        self.union = ::std::option::Option::Some(file_response::Union::Dir(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dir(&mut self) -> &mut FileDirectory {
        if let ::std::option::Option::Some(file_response::Union::Dir(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Dir(FileDirectory::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Dir(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dir(&mut self) -> FileDirectory {
        if self.has_dir() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Dir(v)) => v,
                _ => panic!(),
            }
        } else {
            FileDirectory::new()
        }
    }

    // .hbb.FileTransferBlock block = 2;

    pub fn block(&self) -> &FileTransferBlock {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Block(ref v)) => v,
            _ => <FileTransferBlock as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: FileTransferBlock) {
        self.union = ::std::option::Option::Some(file_response::Union::Block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut FileTransferBlock {
        if let ::std::option::Option::Some(file_response::Union::Block(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Block(FileTransferBlock::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> FileTransferBlock {
        if self.has_block() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Block(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferBlock::new()
        }
    }

    // .hbb.FileTransferError error = 3;

    pub fn error(&self) -> &FileTransferError {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Error(ref v)) => v,
            _ => <FileTransferError as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_error(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: FileTransferError) {
        self.union = ::std::option::Option::Some(file_response::Union::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut FileTransferError {
        if let ::std::option::Option::Some(file_response::Union::Error(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Error(FileTransferError::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> FileTransferError {
        if self.has_error() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferError::new()
        }
    }

    // .hbb.FileTransferDone done = 4;

    pub fn done(&self) -> &FileTransferDone {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Done(ref v)) => v,
            _ => <FileTransferDone as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_done(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_done(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Done(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: FileTransferDone) {
        self.union = ::std::option::Option::Some(file_response::Union::Done(v))
    }

    // Mutable pointer to the field.
    pub fn mut_done(&mut self) -> &mut FileTransferDone {
        if let ::std::option::Option::Some(file_response::Union::Done(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Done(FileTransferDone::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Done(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_done(&mut self) -> FileTransferDone {
        if self.has_done() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Done(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferDone::new()
        }
    }

    // .hbb.FileTransferDigest digest = 5;

    pub fn digest(&self) -> &FileTransferDigest {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Digest(ref v)) => v,
            _ => <FileTransferDigest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_digest(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_digest(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_response::Union::Digest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: FileTransferDigest) {
        self.union = ::std::option::Option::Some(file_response::Union::Digest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_digest(&mut self) -> &mut FileTransferDigest {
        if let ::std::option::Option::Some(file_response::Union::Digest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(file_response::Union::Digest(FileTransferDigest::new()));
        }
        match self.union {
            ::std::option::Option::Some(file_response::Union::Digest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_digest(&mut self) -> FileTransferDigest {
        if self.has_digest() {
            match self.union.take() {
                ::std::option::Option::Some(file_response::Union::Digest(v)) => v,
                _ => panic!(),
            }
        } else {
            FileTransferDigest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileDirectory>(
            "dir",
            FileResponse::has_dir,
            FileResponse::dir,
            FileResponse::mut_dir,
            FileResponse::set_dir,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferBlock>(
            "block",
            FileResponse::has_block,
            FileResponse::block,
            FileResponse::mut_block,
            FileResponse::set_block,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferError>(
            "error",
            FileResponse::has_error,
            FileResponse::error,
            FileResponse::mut_error,
            FileResponse::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferDone>(
            "done",
            FileResponse::has_done,
            FileResponse::done,
            FileResponse::mut_done,
            FileResponse::set_done,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileTransferDigest>(
            "digest",
            FileResponse::has_digest,
            FileResponse::digest,
            FileResponse::mut_digest,
            FileResponse::set_digest,
        ));
        oneofs.push(file_response::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileResponse>(
            "FileResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileResponse {
    const NAME: &'static str = "FileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Dir(is.read_message()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Block(is.read_message()?));
                },
                26 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Error(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Done(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(file_response::Union::Digest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_response::Union::Dir(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_response::Union::Block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_response::Union::Error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_response::Union::Done(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &file_response::Union::Digest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_response::Union::Dir(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &file_response::Union::Block(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &file_response::Union::Error(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &file_response::Union::Done(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &file_response::Union::Digest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileResponse {
        FileResponse::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileResponse {
        static instance: FileResponse = FileResponse {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileResponse`
pub mod file_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.FileResponse.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.dir)
        Dir(super::FileDirectory),
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.block)
        Block(super::FileTransferBlock),
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.error)
        Error(super::FileTransferError),
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.done)
        Done(super::FileTransferDone),
        // @@protoc_insertion_point(oneof_field:hbb.FileResponse.digest)
        Digest(super::FileTransferDigest),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FileResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransferDigest)
pub struct FileTransferDigest {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.file_num)
    pub file_num: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.last_modified)
    pub last_modified: u64,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.file_size)
    pub file_size: u64,
    // @@protoc_insertion_point(field:hbb.FileTransferDigest.is_upload)
    pub is_upload: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferDigest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferDigest {
    fn default() -> &'a FileTransferDigest {
        <FileTransferDigest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferDigest {
    pub fn new() -> FileTransferDigest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferDigest| { &m.id },
            |m: &mut FileTransferDigest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferDigest| { &m.file_num },
            |m: &mut FileTransferDigest| { &mut m.file_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_modified",
            |m: &FileTransferDigest| { &m.last_modified },
            |m: &mut FileTransferDigest| { &mut m.last_modified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_size",
            |m: &FileTransferDigest| { &m.file_size },
            |m: &mut FileTransferDigest| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_upload",
            |m: &FileTransferDigest| { &m.is_upload },
            |m: &mut FileTransferDigest| { &mut m.is_upload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferDigest>(
            "FileTransferDigest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferDigest {
    const NAME: &'static str = "FileTransferDigest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.file_num = is.read_sint32()?;
                },
                24 => {
                    self.last_modified = is.read_uint64()?;
                },
                32 => {
                    self.file_size = is.read_uint64()?;
                },
                40 => {
                    self.is_upload = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.file_num);
        }
        if self.last_modified != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.last_modified);
        }
        if self.file_size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.file_size);
        }
        if self.is_upload != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        if self.last_modified != 0 {
            os.write_uint64(3, self.last_modified)?;
        }
        if self.file_size != 0 {
            os.write_uint64(4, self.file_size)?;
        }
        if self.is_upload != false {
            os.write_bool(5, self.is_upload)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferDigest {
        FileTransferDigest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.last_modified = 0;
        self.file_size = 0;
        self.is_upload = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferDigest {
        static instance: FileTransferDigest = FileTransferDigest {
            id: 0,
            file_num: 0,
            last_modified: 0,
            file_size: 0,
            is_upload: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferDigest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferDigest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferDigest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferDigest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransferBlock)
pub struct FileTransferBlock {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.file_num)
    pub file_num: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.data)
    pub data: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.compressed)
    pub compressed: bool,
    // @@protoc_insertion_point(field:hbb.FileTransferBlock.blk_id)
    pub blk_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferBlock {
    fn default() -> &'a FileTransferBlock {
        <FileTransferBlock as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferBlock {
    pub fn new() -> FileTransferBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferBlock| { &m.id },
            |m: &mut FileTransferBlock| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferBlock| { &m.file_num },
            |m: &mut FileTransferBlock| { &mut m.file_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &FileTransferBlock| { &m.data },
            |m: &mut FileTransferBlock| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compressed",
            |m: &FileTransferBlock| { &m.compressed },
            |m: &mut FileTransferBlock| { &mut m.compressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blk_id",
            |m: &FileTransferBlock| { &m.blk_id },
            |m: &mut FileTransferBlock| { &mut m.blk_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferBlock>(
            "FileTransferBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferBlock {
    const NAME: &'static str = "FileTransferBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.file_num = is.read_sint32()?;
                },
                26 => {
                    self.data = is.read_tokio_bytes()?;
                },
                32 => {
                    self.compressed = is.read_bool()?;
                },
                40 => {
                    self.blk_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.file_num);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if self.compressed != false {
            my_size += 1 + 1;
        }
        if self.blk_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.blk_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if self.compressed != false {
            os.write_bool(4, self.compressed)?;
        }
        if self.blk_id != 0 {
            os.write_uint32(5, self.blk_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferBlock {
        FileTransferBlock::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.data.clear();
        self.compressed = false;
        self.blk_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferBlock {
        static instance: FileTransferBlock = FileTransferBlock {
            id: 0,
            file_num: 0,
            data: ::bytes::Bytes::new(),
            compressed: false,
            blk_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransferError)
pub struct FileTransferError {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferError.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferError.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileTransferError.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferError {
    fn default() -> &'a FileTransferError {
        <FileTransferError as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferError {
    pub fn new() -> FileTransferError {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferError| { &m.id },
            |m: &mut FileTransferError| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &FileTransferError| { &m.error },
            |m: &mut FileTransferError| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferError| { &m.file_num },
            |m: &mut FileTransferError| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferError>(
            "FileTransferError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferError {
    const NAME: &'static str = "FileTransferError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                24 => {
                    self.file_num = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.file_num != 0 {
            os.write_sint32(3, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferError {
        FileTransferError::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.error.clear();
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferError {
        static instance: FileTransferError = FileTransferError {
            id: 0,
            error: ::std::string::String::new(),
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransferSendRequest)
pub struct FileTransferSendRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferSendRequest.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferSendRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileTransferSendRequest.include_hidden)
    pub include_hidden: bool,
    // @@protoc_insertion_point(field:hbb.FileTransferSendRequest.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferSendRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferSendRequest {
    fn default() -> &'a FileTransferSendRequest {
        <FileTransferSendRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferSendRequest {
    pub fn new() -> FileTransferSendRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferSendRequest| { &m.id },
            |m: &mut FileTransferSendRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileTransferSendRequest| { &m.path },
            |m: &mut FileTransferSendRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_hidden",
            |m: &FileTransferSendRequest| { &m.include_hidden },
            |m: &mut FileTransferSendRequest| { &mut m.include_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferSendRequest| { &m.file_num },
            |m: &mut FileTransferSendRequest| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferSendRequest>(
            "FileTransferSendRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferSendRequest {
    const NAME: &'static str = "FileTransferSendRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.include_hidden = is.read_bool()?;
                },
                32 => {
                    self.file_num = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.include_hidden != false {
            my_size += 1 + 1;
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.include_hidden != false {
            os.write_bool(3, self.include_hidden)?;
        }
        if self.file_num != 0 {
            os.write_int32(4, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferSendRequest {
        FileTransferSendRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.include_hidden = false;
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferSendRequest {
        static instance: FileTransferSendRequest = FileTransferSendRequest {
            id: 0,
            path: ::std::string::String::new(),
            include_hidden: false,
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferSendRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferSendRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferSendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferSendRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransferSendConfirmRequest)
pub struct FileTransferSendConfirmRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferSendConfirmRequest.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferSendConfirmRequest.file_num)
    pub file_num: i32,
    // message oneof groups
    pub union: ::std::option::Option<file_transfer_send_confirm_request::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferSendConfirmRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferSendConfirmRequest {
    fn default() -> &'a FileTransferSendConfirmRequest {
        <FileTransferSendConfirmRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferSendConfirmRequest {
    pub fn new() -> FileTransferSendConfirmRequest {
        ::std::default::Default::default()
    }

    // bool skip = 3;

    pub fn skip(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_transfer_send_confirm_request::Union::Skip(v)) => v,
            _ => false,
        }
    }

    pub fn clear_skip(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_skip(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_transfer_send_confirm_request::Union::Skip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(file_transfer_send_confirm_request::Union::Skip(v))
    }

    // uint32 offset_blk = 4;

    pub fn offset_blk(&self) -> u32 {
        match self.union {
            ::std::option::Option::Some(file_transfer_send_confirm_request::Union::OffsetBlk(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_offset_blk(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_offset_blk(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(file_transfer_send_confirm_request::Union::OffsetBlk(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offset_blk(&mut self, v: u32) {
        self.union = ::std::option::Option::Some(file_transfer_send_confirm_request::Union::OffsetBlk(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferSendConfirmRequest| { &m.id },
            |m: &mut FileTransferSendConfirmRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferSendConfirmRequest| { &m.file_num },
            |m: &mut FileTransferSendConfirmRequest| { &mut m.file_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "skip",
            FileTransferSendConfirmRequest::has_skip,
            FileTransferSendConfirmRequest::skip,
            FileTransferSendConfirmRequest::set_skip,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "offset_blk",
            FileTransferSendConfirmRequest::has_offset_blk,
            FileTransferSendConfirmRequest::offset_blk,
            FileTransferSendConfirmRequest::set_offset_blk,
        ));
        oneofs.push(file_transfer_send_confirm_request::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferSendConfirmRequest>(
            "FileTransferSendConfirmRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferSendConfirmRequest {
    const NAME: &'static str = "FileTransferSendConfirmRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.file_num = is.read_sint32()?;
                },
                24 => {
                    self.union = ::std::option::Option::Some(file_transfer_send_confirm_request::Union::Skip(is.read_bool()?));
                },
                32 => {
                    self.union = ::std::option::Option::Some(file_transfer_send_confirm_request::Union::OffsetBlk(is.read_uint32()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.file_num);
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_transfer_send_confirm_request::Union::Skip(v) => {
                    my_size += 1 + 1;
                },
                &file_transfer_send_confirm_request::Union::OffsetBlk(v) => {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &file_transfer_send_confirm_request::Union::Skip(v) => {
                    os.write_bool(3, v)?;
                },
                &file_transfer_send_confirm_request::Union::OffsetBlk(v) => {
                    os.write_uint32(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferSendConfirmRequest {
        FileTransferSendConfirmRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferSendConfirmRequest {
        static instance: FileTransferSendConfirmRequest = FileTransferSendConfirmRequest {
            id: 0,
            file_num: 0,
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferSendConfirmRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferSendConfirmRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferSendConfirmRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferSendConfirmRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileTransferSendConfirmRequest`
pub mod file_transfer_send_confirm_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.FileTransferSendConfirmRequest.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.FileTransferSendConfirmRequest.skip)
        Skip(bool),
        // @@protoc_insertion_point(oneof_field:hbb.FileTransferSendConfirmRequest.offset_blk)
        OffsetBlk(u32),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FileTransferSendConfirmRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransferDone)
pub struct FileTransferDone {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferDone.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferDone.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferDone.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferDone {
    fn default() -> &'a FileTransferDone {
        <FileTransferDone as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferDone {
    pub fn new() -> FileTransferDone {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferDone| { &m.id },
            |m: &mut FileTransferDone| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferDone| { &m.file_num },
            |m: &mut FileTransferDone| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferDone>(
            "FileTransferDone",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferDone {
    const NAME: &'static str = "FileTransferDone";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.file_num = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.file_num != 0 {
            os.write_sint32(2, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferDone {
        FileTransferDone::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferDone {
        static instance: FileTransferDone = FileTransferDone {
            id: 0,
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferDone {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferDone").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferDone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferDone {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileTransferReceiveRequest)
pub struct FileTransferReceiveRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.files)
    pub files: ::std::vec::Vec<FileEntry>,
    // @@protoc_insertion_point(field:hbb.FileTransferReceiveRequest.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileTransferReceiveRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileTransferReceiveRequest {
    fn default() -> &'a FileTransferReceiveRequest {
        <FileTransferReceiveRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileTransferReceiveRequest {
    pub fn new() -> FileTransferReceiveRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileTransferReceiveRequest| { &m.id },
            |m: &mut FileTransferReceiveRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileTransferReceiveRequest| { &m.path },
            |m: &mut FileTransferReceiveRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &FileTransferReceiveRequest| { &m.files },
            |m: &mut FileTransferReceiveRequest| { &mut m.files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileTransferReceiveRequest| { &m.file_num },
            |m: &mut FileTransferReceiveRequest| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileTransferReceiveRequest>(
            "FileTransferReceiveRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileTransferReceiveRequest {
    const NAME: &'static str = "FileTransferReceiveRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                26 => {
                    self.files.push(is.read_message()?);
                },
                32 => {
                    self.file_num = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.file_num != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.file_num != 0 {
            os.write_int32(4, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileTransferReceiveRequest {
        FileTransferReceiveRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.files.clear();
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileTransferReceiveRequest {
        static instance: FileTransferReceiveRequest = FileTransferReceiveRequest {
            id: 0,
            path: ::std::string::String::new(),
            files: ::std::vec::Vec::new(),
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileTransferReceiveRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileTransferReceiveRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileTransferReceiveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileTransferReceiveRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileRemoveDir)
pub struct FileRemoveDir {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileRemoveDir.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileRemoveDir.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileRemoveDir.recursive)
    pub recursive: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileRemoveDir.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileRemoveDir {
    fn default() -> &'a FileRemoveDir {
        <FileRemoveDir as ::protobuf::Message>::default_instance()
    }
}

impl FileRemoveDir {
    pub fn new() -> FileRemoveDir {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileRemoveDir| { &m.id },
            |m: &mut FileRemoveDir| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileRemoveDir| { &m.path },
            |m: &mut FileRemoveDir| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recursive",
            |m: &FileRemoveDir| { &m.recursive },
            |m: &mut FileRemoveDir| { &mut m.recursive },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileRemoveDir>(
            "FileRemoveDir",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileRemoveDir {
    const NAME: &'static str = "FileRemoveDir";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.recursive = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.recursive != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.recursive != false {
            os.write_bool(3, self.recursive)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileRemoveDir {
        FileRemoveDir::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.recursive = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileRemoveDir {
        static instance: FileRemoveDir = FileRemoveDir {
            id: 0,
            path: ::std::string::String::new(),
            recursive: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileRemoveDir {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileRemoveDir").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileRemoveDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileRemoveDir {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileRemoveFile)
pub struct FileRemoveFile {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileRemoveFile.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileRemoveFile.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.FileRemoveFile.file_num)
    pub file_num: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileRemoveFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileRemoveFile {
    fn default() -> &'a FileRemoveFile {
        <FileRemoveFile as ::protobuf::Message>::default_instance()
    }
}

impl FileRemoveFile {
    pub fn new() -> FileRemoveFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileRemoveFile| { &m.id },
            |m: &mut FileRemoveFile| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileRemoveFile| { &m.path },
            |m: &mut FileRemoveFile| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_num",
            |m: &FileRemoveFile| { &m.file_num },
            |m: &mut FileRemoveFile| { &mut m.file_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileRemoveFile>(
            "FileRemoveFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileRemoveFile {
    const NAME: &'static str = "FileRemoveFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                24 => {
                    self.file_num = is.read_sint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if self.file_num != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.file_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if self.file_num != 0 {
            os.write_sint32(3, self.file_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileRemoveFile {
        FileRemoveFile::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.file_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileRemoveFile {
        static instance: FileRemoveFile = FileRemoveFile {
            id: 0,
            path: ::std::string::String::new(),
            file_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileRemoveFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileRemoveFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileRemoveFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileRemoveFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.FileDirCreate)
pub struct FileDirCreate {
    // message fields
    // @@protoc_insertion_point(field:hbb.FileDirCreate.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.FileDirCreate.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.FileDirCreate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDirCreate {
    fn default() -> &'a FileDirCreate {
        <FileDirCreate as ::protobuf::Message>::default_instance()
    }
}

impl FileDirCreate {
    pub fn new() -> FileDirCreate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FileDirCreate| { &m.id },
            |m: &mut FileDirCreate| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FileDirCreate| { &m.path },
            |m: &mut FileDirCreate| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileDirCreate>(
            "FileDirCreate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileDirCreate {
    const NAME: &'static str = "FileDirCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDirCreate {
        FileDirCreate::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDirCreate {
        static instance: FileDirCreate = FileDirCreate {
            id: 0,
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileDirCreate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDirCreate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDirCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDirCreate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CliprdrMonitorReady)
pub struct CliprdrMonitorReady {
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrMonitorReady.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrMonitorReady {
    fn default() -> &'a CliprdrMonitorReady {
        <CliprdrMonitorReady as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrMonitorReady {
    pub fn new() -> CliprdrMonitorReady {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrMonitorReady>(
            "CliprdrMonitorReady",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrMonitorReady {
    const NAME: &'static str = "CliprdrMonitorReady";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrMonitorReady {
        CliprdrMonitorReady::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrMonitorReady {
        static instance: CliprdrMonitorReady = CliprdrMonitorReady {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrMonitorReady {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrMonitorReady").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrMonitorReady {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrMonitorReady {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CliprdrFormat)
pub struct CliprdrFormat {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrFormat.id)
    pub id: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFormat.format)
    pub format: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrFormat {
    fn default() -> &'a CliprdrFormat {
        <CliprdrFormat as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrFormat {
    pub fn new() -> CliprdrFormat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CliprdrFormat| { &m.id },
            |m: &mut CliprdrFormat| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &CliprdrFormat| { &m.format },
            |m: &mut CliprdrFormat| { &mut m.format },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrFormat>(
            "CliprdrFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrFormat {
    const NAME: &'static str = "CliprdrFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.id = is.read_int32()?;
                },
                26 => {
                    self.format = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.id);
        }
        if !self.format.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.format);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(2, self.id)?;
        }
        if !self.format.is_empty() {
            os.write_string(3, &self.format)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrFormat {
        CliprdrFormat::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.format.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrFormat {
        static instance: CliprdrFormat = CliprdrFormat {
            id: 0,
            format: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CliprdrServerFormatList)
pub struct CliprdrServerFormatList {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatList.formats)
    pub formats: ::std::vec::Vec<CliprdrFormat>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrServerFormatList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrServerFormatList {
    fn default() -> &'a CliprdrServerFormatList {
        <CliprdrServerFormatList as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrServerFormatList {
    pub fn new() -> CliprdrServerFormatList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "formats",
            |m: &CliprdrServerFormatList| { &m.formats },
            |m: &mut CliprdrServerFormatList| { &mut m.formats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrServerFormatList>(
            "CliprdrServerFormatList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrServerFormatList {
    const NAME: &'static str = "CliprdrServerFormatList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.formats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.formats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.formats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrServerFormatList {
        CliprdrServerFormatList::new()
    }

    fn clear(&mut self) {
        self.formats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrServerFormatList {
        static instance: CliprdrServerFormatList = CliprdrServerFormatList {
            formats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrServerFormatList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrServerFormatList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrServerFormatList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrServerFormatList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CliprdrServerFormatListResponse)
pub struct CliprdrServerFormatListResponse {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatListResponse.msg_flags)
    pub msg_flags: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrServerFormatListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrServerFormatListResponse {
    fn default() -> &'a CliprdrServerFormatListResponse {
        <CliprdrServerFormatListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrServerFormatListResponse {
    pub fn new() -> CliprdrServerFormatListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_flags",
            |m: &CliprdrServerFormatListResponse| { &m.msg_flags },
            |m: &mut CliprdrServerFormatListResponse| { &mut m.msg_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrServerFormatListResponse>(
            "CliprdrServerFormatListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrServerFormatListResponse {
    const NAME: &'static str = "CliprdrServerFormatListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.msg_flags = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msg_flags != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.msg_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msg_flags != 0 {
            os.write_int32(2, self.msg_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrServerFormatListResponse {
        CliprdrServerFormatListResponse::new()
    }

    fn clear(&mut self) {
        self.msg_flags = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrServerFormatListResponse {
        static instance: CliprdrServerFormatListResponse = CliprdrServerFormatListResponse {
            msg_flags: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrServerFormatListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrServerFormatListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrServerFormatListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrServerFormatListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CliprdrServerFormatDataRequest)
pub struct CliprdrServerFormatDataRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatDataRequest.requested_format_id)
    pub requested_format_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrServerFormatDataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrServerFormatDataRequest {
    fn default() -> &'a CliprdrServerFormatDataRequest {
        <CliprdrServerFormatDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrServerFormatDataRequest {
    pub fn new() -> CliprdrServerFormatDataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requested_format_id",
            |m: &CliprdrServerFormatDataRequest| { &m.requested_format_id },
            |m: &mut CliprdrServerFormatDataRequest| { &mut m.requested_format_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrServerFormatDataRequest>(
            "CliprdrServerFormatDataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrServerFormatDataRequest {
    const NAME: &'static str = "CliprdrServerFormatDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.requested_format_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.requested_format_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.requested_format_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.requested_format_id != 0 {
            os.write_int32(2, self.requested_format_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrServerFormatDataRequest {
        CliprdrServerFormatDataRequest::new()
    }

    fn clear(&mut self) {
        self.requested_format_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrServerFormatDataRequest {
        static instance: CliprdrServerFormatDataRequest = CliprdrServerFormatDataRequest {
            requested_format_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrServerFormatDataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrServerFormatDataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrServerFormatDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrServerFormatDataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CliprdrServerFormatDataResponse)
pub struct CliprdrServerFormatDataResponse {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatDataResponse.msg_flags)
    pub msg_flags: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrServerFormatDataResponse.format_data)
    pub format_data: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrServerFormatDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrServerFormatDataResponse {
    fn default() -> &'a CliprdrServerFormatDataResponse {
        <CliprdrServerFormatDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrServerFormatDataResponse {
    pub fn new() -> CliprdrServerFormatDataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_flags",
            |m: &CliprdrServerFormatDataResponse| { &m.msg_flags },
            |m: &mut CliprdrServerFormatDataResponse| { &mut m.msg_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format_data",
            |m: &CliprdrServerFormatDataResponse| { &m.format_data },
            |m: &mut CliprdrServerFormatDataResponse| { &mut m.format_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrServerFormatDataResponse>(
            "CliprdrServerFormatDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrServerFormatDataResponse {
    const NAME: &'static str = "CliprdrServerFormatDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.msg_flags = is.read_int32()?;
                },
                26 => {
                    self.format_data = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msg_flags != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.msg_flags);
        }
        if !self.format_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.format_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msg_flags != 0 {
            os.write_int32(2, self.msg_flags)?;
        }
        if !self.format_data.is_empty() {
            os.write_bytes(3, &self.format_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrServerFormatDataResponse {
        CliprdrServerFormatDataResponse::new()
    }

    fn clear(&mut self) {
        self.msg_flags = 0;
        self.format_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrServerFormatDataResponse {
        static instance: CliprdrServerFormatDataResponse = CliprdrServerFormatDataResponse {
            msg_flags: 0,
            format_data: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrServerFormatDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrServerFormatDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrServerFormatDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrServerFormatDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CliprdrFileContentsRequest)
pub struct CliprdrFileContentsRequest {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.stream_id)
    pub stream_id: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.list_index)
    pub list_index: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.dw_flags)
    pub dw_flags: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.n_position_low)
    pub n_position_low: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.n_position_high)
    pub n_position_high: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.cb_requested)
    pub cb_requested: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.have_clip_data_id)
    pub have_clip_data_id: bool,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsRequest.clip_data_id)
    pub clip_data_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrFileContentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrFileContentsRequest {
    fn default() -> &'a CliprdrFileContentsRequest {
        <CliprdrFileContentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrFileContentsRequest {
    pub fn new() -> CliprdrFileContentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream_id",
            |m: &CliprdrFileContentsRequest| { &m.stream_id },
            |m: &mut CliprdrFileContentsRequest| { &mut m.stream_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "list_index",
            |m: &CliprdrFileContentsRequest| { &m.list_index },
            |m: &mut CliprdrFileContentsRequest| { &mut m.list_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dw_flags",
            |m: &CliprdrFileContentsRequest| { &m.dw_flags },
            |m: &mut CliprdrFileContentsRequest| { &mut m.dw_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "n_position_low",
            |m: &CliprdrFileContentsRequest| { &m.n_position_low },
            |m: &mut CliprdrFileContentsRequest| { &mut m.n_position_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "n_position_high",
            |m: &CliprdrFileContentsRequest| { &m.n_position_high },
            |m: &mut CliprdrFileContentsRequest| { &mut m.n_position_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cb_requested",
            |m: &CliprdrFileContentsRequest| { &m.cb_requested },
            |m: &mut CliprdrFileContentsRequest| { &mut m.cb_requested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "have_clip_data_id",
            |m: &CliprdrFileContentsRequest| { &m.have_clip_data_id },
            |m: &mut CliprdrFileContentsRequest| { &mut m.have_clip_data_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clip_data_id",
            |m: &CliprdrFileContentsRequest| { &m.clip_data_id },
            |m: &mut CliprdrFileContentsRequest| { &mut m.clip_data_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrFileContentsRequest>(
            "CliprdrFileContentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrFileContentsRequest {
    const NAME: &'static str = "CliprdrFileContentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.stream_id = is.read_int32()?;
                },
                24 => {
                    self.list_index = is.read_int32()?;
                },
                32 => {
                    self.dw_flags = is.read_int32()?;
                },
                40 => {
                    self.n_position_low = is.read_int32()?;
                },
                48 => {
                    self.n_position_high = is.read_int32()?;
                },
                56 => {
                    self.cb_requested = is.read_int32()?;
                },
                64 => {
                    self.have_clip_data_id = is.read_bool()?;
                },
                72 => {
                    self.clip_data_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.stream_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.stream_id);
        }
        if self.list_index != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.list_index);
        }
        if self.dw_flags != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.dw_flags);
        }
        if self.n_position_low != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.n_position_low);
        }
        if self.n_position_high != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.n_position_high);
        }
        if self.cb_requested != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.cb_requested);
        }
        if self.have_clip_data_id != false {
            my_size += 1 + 1;
        }
        if self.clip_data_id != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.clip_data_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.stream_id != 0 {
            os.write_int32(2, self.stream_id)?;
        }
        if self.list_index != 0 {
            os.write_int32(3, self.list_index)?;
        }
        if self.dw_flags != 0 {
            os.write_int32(4, self.dw_flags)?;
        }
        if self.n_position_low != 0 {
            os.write_int32(5, self.n_position_low)?;
        }
        if self.n_position_high != 0 {
            os.write_int32(6, self.n_position_high)?;
        }
        if self.cb_requested != 0 {
            os.write_int32(7, self.cb_requested)?;
        }
        if self.have_clip_data_id != false {
            os.write_bool(8, self.have_clip_data_id)?;
        }
        if self.clip_data_id != 0 {
            os.write_int32(9, self.clip_data_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrFileContentsRequest {
        CliprdrFileContentsRequest::new()
    }

    fn clear(&mut self) {
        self.stream_id = 0;
        self.list_index = 0;
        self.dw_flags = 0;
        self.n_position_low = 0;
        self.n_position_high = 0;
        self.cb_requested = 0;
        self.have_clip_data_id = false;
        self.clip_data_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrFileContentsRequest {
        static instance: CliprdrFileContentsRequest = CliprdrFileContentsRequest {
            stream_id: 0,
            list_index: 0,
            dw_flags: 0,
            n_position_low: 0,
            n_position_high: 0,
            cb_requested: 0,
            have_clip_data_id: false,
            clip_data_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrFileContentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrFileContentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrFileContentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrFileContentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.CliprdrFileContentsResponse)
pub struct CliprdrFileContentsResponse {
    // message fields
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsResponse.msg_flags)
    pub msg_flags: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsResponse.stream_id)
    pub stream_id: i32,
    // @@protoc_insertion_point(field:hbb.CliprdrFileContentsResponse.requested_data)
    pub requested_data: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.CliprdrFileContentsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliprdrFileContentsResponse {
    fn default() -> &'a CliprdrFileContentsResponse {
        <CliprdrFileContentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CliprdrFileContentsResponse {
    pub fn new() -> CliprdrFileContentsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_flags",
            |m: &CliprdrFileContentsResponse| { &m.msg_flags },
            |m: &mut CliprdrFileContentsResponse| { &mut m.msg_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream_id",
            |m: &CliprdrFileContentsResponse| { &m.stream_id },
            |m: &mut CliprdrFileContentsResponse| { &mut m.stream_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requested_data",
            |m: &CliprdrFileContentsResponse| { &m.requested_data },
            |m: &mut CliprdrFileContentsResponse| { &mut m.requested_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliprdrFileContentsResponse>(
            "CliprdrFileContentsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliprdrFileContentsResponse {
    const NAME: &'static str = "CliprdrFileContentsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.msg_flags = is.read_int32()?;
                },
                32 => {
                    self.stream_id = is.read_int32()?;
                },
                42 => {
                    self.requested_data = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msg_flags != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.msg_flags);
        }
        if self.stream_id != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.stream_id);
        }
        if !self.requested_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.requested_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msg_flags != 0 {
            os.write_int32(3, self.msg_flags)?;
        }
        if self.stream_id != 0 {
            os.write_int32(4, self.stream_id)?;
        }
        if !self.requested_data.is_empty() {
            os.write_bytes(5, &self.requested_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliprdrFileContentsResponse {
        CliprdrFileContentsResponse::new()
    }

    fn clear(&mut self) {
        self.msg_flags = 0;
        self.stream_id = 0;
        self.requested_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliprdrFileContentsResponse {
        static instance: CliprdrFileContentsResponse = CliprdrFileContentsResponse {
            msg_flags: 0,
            stream_id: 0,
            requested_data: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliprdrFileContentsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliprdrFileContentsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliprdrFileContentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliprdrFileContentsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.Cliprdr)
pub struct Cliprdr {
    // message oneof groups
    pub union: ::std::option::Option<cliprdr::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Cliprdr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cliprdr {
    fn default() -> &'a Cliprdr {
        <Cliprdr as ::protobuf::Message>::default_instance()
    }
}

impl Cliprdr {
    pub fn new() -> Cliprdr {
        ::std::default::Default::default()
    }

    // .hbb.CliprdrMonitorReady ready = 1;

    pub fn ready(&self) -> &CliprdrMonitorReady {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::Ready(ref v)) => v,
            _ => <CliprdrMonitorReady as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ready(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_ready(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::Ready(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ready(&mut self, v: CliprdrMonitorReady) {
        self.union = ::std::option::Option::Some(cliprdr::Union::Ready(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ready(&mut self) -> &mut CliprdrMonitorReady {
        if let ::std::option::Option::Some(cliprdr::Union::Ready(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::Ready(CliprdrMonitorReady::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::Ready(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ready(&mut self) -> CliprdrMonitorReady {
        if self.has_ready() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::Ready(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrMonitorReady::new()
        }
    }

    // .hbb.CliprdrServerFormatList format_list = 2;

    pub fn format_list(&self) -> &CliprdrServerFormatList {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatList(ref v)) => v,
            _ => <CliprdrServerFormatList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_format_list(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_format_list(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_format_list(&mut self, v: CliprdrServerFormatList) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FormatList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_format_list(&mut self) -> &mut CliprdrServerFormatList {
        if let ::std::option::Option::Some(cliprdr::Union::FormatList(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FormatList(CliprdrServerFormatList::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_format_list(&mut self) -> CliprdrServerFormatList {
        if self.has_format_list() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FormatList(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrServerFormatList::new()
        }
    }

    // .hbb.CliprdrServerFormatListResponse format_list_response = 3;

    pub fn format_list_response(&self) -> &CliprdrServerFormatListResponse {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatListResponse(ref v)) => v,
            _ => <CliprdrServerFormatListResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_format_list_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_format_list_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatListResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_format_list_response(&mut self, v: CliprdrServerFormatListResponse) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FormatListResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_format_list_response(&mut self) -> &mut CliprdrServerFormatListResponse {
        if let ::std::option::Option::Some(cliprdr::Union::FormatListResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FormatListResponse(CliprdrServerFormatListResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatListResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_format_list_response(&mut self) -> CliprdrServerFormatListResponse {
        if self.has_format_list_response() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FormatListResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrServerFormatListResponse::new()
        }
    }

    // .hbb.CliprdrServerFormatDataRequest format_data_request = 4;

    pub fn format_data_request(&self) -> &CliprdrServerFormatDataRequest {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(ref v)) => v,
            _ => <CliprdrServerFormatDataRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_format_data_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_format_data_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_format_data_request(&mut self, v: CliprdrServerFormatDataRequest) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_format_data_request(&mut self) -> &mut CliprdrServerFormatDataRequest {
        if let ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(CliprdrServerFormatDataRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_format_data_request(&mut self) -> CliprdrServerFormatDataRequest {
        if self.has_format_data_request() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrServerFormatDataRequest::new()
        }
    }

    // .hbb.CliprdrServerFormatDataResponse format_data_response = 5;

    pub fn format_data_response(&self) -> &CliprdrServerFormatDataResponse {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(ref v)) => v,
            _ => <CliprdrServerFormatDataResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_format_data_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_format_data_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_format_data_response(&mut self, v: CliprdrServerFormatDataResponse) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_format_data_response(&mut self) -> &mut CliprdrServerFormatDataResponse {
        if let ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(CliprdrServerFormatDataResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_format_data_response(&mut self) -> CliprdrServerFormatDataResponse {
        if self.has_format_data_response() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrServerFormatDataResponse::new()
        }
    }

    // .hbb.CliprdrFileContentsRequest file_contents_request = 6;

    pub fn file_contents_request(&self) -> &CliprdrFileContentsRequest {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(ref v)) => v,
            _ => <CliprdrFileContentsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_contents_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_contents_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_contents_request(&mut self, v: CliprdrFileContentsRequest) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_contents_request(&mut self) -> &mut CliprdrFileContentsRequest {
        if let ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(CliprdrFileContentsRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_contents_request(&mut self) -> CliprdrFileContentsRequest {
        if self.has_file_contents_request() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrFileContentsRequest::new()
        }
    }

    // .hbb.CliprdrFileContentsResponse file_contents_response = 7;

    pub fn file_contents_response(&self) -> &CliprdrFileContentsResponse {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(ref v)) => v,
            _ => <CliprdrFileContentsResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_contents_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_contents_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_contents_response(&mut self, v: CliprdrFileContentsResponse) {
        self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_contents_response(&mut self) -> &mut CliprdrFileContentsResponse {
        if let ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(CliprdrFileContentsResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_contents_response(&mut self) -> CliprdrFileContentsResponse {
        if self.has_file_contents_response() {
            match self.union.take() {
                ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            CliprdrFileContentsResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrMonitorReady>(
            "ready",
            Cliprdr::has_ready,
            Cliprdr::ready,
            Cliprdr::mut_ready,
            Cliprdr::set_ready,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrServerFormatList>(
            "format_list",
            Cliprdr::has_format_list,
            Cliprdr::format_list,
            Cliprdr::mut_format_list,
            Cliprdr::set_format_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrServerFormatListResponse>(
            "format_list_response",
            Cliprdr::has_format_list_response,
            Cliprdr::format_list_response,
            Cliprdr::mut_format_list_response,
            Cliprdr::set_format_list_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrServerFormatDataRequest>(
            "format_data_request",
            Cliprdr::has_format_data_request,
            Cliprdr::format_data_request,
            Cliprdr::mut_format_data_request,
            Cliprdr::set_format_data_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrServerFormatDataResponse>(
            "format_data_response",
            Cliprdr::has_format_data_response,
            Cliprdr::format_data_response,
            Cliprdr::mut_format_data_response,
            Cliprdr::set_format_data_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrFileContentsRequest>(
            "file_contents_request",
            Cliprdr::has_file_contents_request,
            Cliprdr::file_contents_request,
            Cliprdr::mut_file_contents_request,
            Cliprdr::set_file_contents_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CliprdrFileContentsResponse>(
            "file_contents_response",
            Cliprdr::has_file_contents_response,
            Cliprdr::file_contents_response,
            Cliprdr::mut_file_contents_response,
            Cliprdr::set_file_contents_response,
        ));
        oneofs.push(cliprdr::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cliprdr>(
            "Cliprdr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cliprdr {
    const NAME: &'static str = "Cliprdr";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::Ready(is.read_message()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FormatList(is.read_message()?));
                },
                26 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FormatListResponse(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataRequest(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FormatDataResponse(is.read_message()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsRequest(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(cliprdr::Union::FileContentsResponse(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &cliprdr::Union::Ready(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FormatList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FormatListResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FormatDataRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FormatDataResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FileContentsRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cliprdr::Union::FileContentsResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &cliprdr::Union::Ready(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &cliprdr::Union::FormatList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cliprdr::Union::FormatListResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cliprdr::Union::FormatDataRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &cliprdr::Union::FormatDataResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &cliprdr::Union::FileContentsRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &cliprdr::Union::FileContentsResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cliprdr {
        Cliprdr::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cliprdr {
        static instance: Cliprdr = Cliprdr {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Cliprdr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cliprdr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cliprdr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cliprdr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Cliprdr`
pub mod cliprdr {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.Cliprdr.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.ready)
        Ready(super::CliprdrMonitorReady),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.format_list)
        FormatList(super::CliprdrServerFormatList),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.format_list_response)
        FormatListResponse(super::CliprdrServerFormatListResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.format_data_request)
        FormatDataRequest(super::CliprdrServerFormatDataRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.format_data_response)
        FormatDataResponse(super::CliprdrServerFormatDataResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.file_contents_request)
        FileContentsRequest(super::CliprdrFileContentsRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Cliprdr.file_contents_response)
        FileContentsResponse(super::CliprdrFileContentsResponse),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Cliprdr as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.SwitchDisplay)
pub struct SwitchDisplay {
    // message fields
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.display)
    pub display: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.x)
    pub x: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.y)
    pub y: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.width)
    pub width: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.height)
    pub height: i32,
    // @@protoc_insertion_point(field:hbb.SwitchDisplay.cursor_embedded)
    pub cursor_embedded: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SwitchDisplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwitchDisplay {
    fn default() -> &'a SwitchDisplay {
        <SwitchDisplay as ::protobuf::Message>::default_instance()
    }
}

impl SwitchDisplay {
    pub fn new() -> SwitchDisplay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display",
            |m: &SwitchDisplay| { &m.display },
            |m: &mut SwitchDisplay| { &mut m.display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &SwitchDisplay| { &m.x },
            |m: &mut SwitchDisplay| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &SwitchDisplay| { &m.y },
            |m: &mut SwitchDisplay| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &SwitchDisplay| { &m.width },
            |m: &mut SwitchDisplay| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &SwitchDisplay| { &m.height },
            |m: &mut SwitchDisplay| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor_embedded",
            |m: &SwitchDisplay| { &m.cursor_embedded },
            |m: &mut SwitchDisplay| { &mut m.cursor_embedded },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchDisplay>(
            "SwitchDisplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchDisplay {
    const NAME: &'static str = "SwitchDisplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.display = is.read_int32()?;
                },
                16 => {
                    self.x = is.read_sint32()?;
                },
                24 => {
                    self.y = is.read_sint32()?;
                },
                32 => {
                    self.width = is.read_int32()?;
                },
                40 => {
                    self.height = is.read_int32()?;
                },
                48 => {
                    self.cursor_embedded = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.display != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.display);
        }
        if self.x != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.y);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.height);
        }
        if self.cursor_embedded != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.display != 0 {
            os.write_int32(1, self.display)?;
        }
        if self.x != 0 {
            os.write_sint32(2, self.x)?;
        }
        if self.y != 0 {
            os.write_sint32(3, self.y)?;
        }
        if self.width != 0 {
            os.write_int32(4, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(5, self.height)?;
        }
        if self.cursor_embedded != false {
            os.write_bool(6, self.cursor_embedded)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchDisplay {
        SwitchDisplay::new()
    }

    fn clear(&mut self) {
        self.display = 0;
        self.x = 0;
        self.y = 0;
        self.width = 0;
        self.height = 0;
        self.cursor_embedded = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchDisplay {
        static instance: SwitchDisplay = SwitchDisplay {
            display: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            cursor_embedded: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchDisplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchDisplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwitchDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchDisplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.PermissionInfo)
pub struct PermissionInfo {
    // message fields
    // @@protoc_insertion_point(field:hbb.PermissionInfo.permission)
    pub permission: ::protobuf::EnumOrUnknown<permission_info::Permission>,
    // @@protoc_insertion_point(field:hbb.PermissionInfo.enabled)
    pub enabled: bool,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PermissionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionInfo {
    fn default() -> &'a PermissionInfo {
        <PermissionInfo as ::protobuf::Message>::default_instance()
    }
}

impl PermissionInfo {
    pub fn new() -> PermissionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "permission",
            |m: &PermissionInfo| { &m.permission },
            |m: &mut PermissionInfo| { &mut m.permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enabled",
            |m: &PermissionInfo| { &m.enabled },
            |m: &mut PermissionInfo| { &mut m.enabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionInfo>(
            "PermissionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionInfo {
    const NAME: &'static str = "PermissionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.enabled = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.permission != ::protobuf::EnumOrUnknown::new(permission_info::Permission::Keyboard) {
            my_size += ::protobuf::rt::int32_size(1, self.permission.value());
        }
        if self.enabled != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.permission != ::protobuf::EnumOrUnknown::new(permission_info::Permission::Keyboard) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.permission))?;
        }
        if self.enabled != false {
            os.write_bool(2, self.enabled)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionInfo {
        PermissionInfo::new()
    }

    fn clear(&mut self) {
        self.permission = ::protobuf::EnumOrUnknown::new(permission_info::Permission::Keyboard);
        self.enabled = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionInfo {
        static instance: PermissionInfo = PermissionInfo {
            permission: ::protobuf::EnumOrUnknown::from_i32(0),
            enabled: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PermissionInfo`
pub mod permission_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.PermissionInfo.Permission)
    pub enum Permission {
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Keyboard)
        Keyboard = 0,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Clipboard)
        Clipboard = 2,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Audio)
        Audio = 3,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.File)
        File = 4,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Restart)
        Restart = 5,
        // @@protoc_insertion_point(enum_value:hbb.PermissionInfo.Permission.Recording)
        Recording = 6,
    }

    impl ::protobuf::Enum for Permission {
        const NAME: &'static str = "Permission";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Permission> {
            match value {
                0 => ::std::option::Option::Some(Permission::Keyboard),
                2 => ::std::option::Option::Some(Permission::Clipboard),
                3 => ::std::option::Option::Some(Permission::Audio),
                4 => ::std::option::Option::Some(Permission::File),
                5 => ::std::option::Option::Some(Permission::Restart),
                6 => ::std::option::Option::Some(Permission::Recording),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Permission] = &[
            Permission::Keyboard,
            Permission::Clipboard,
            Permission::Audio,
            Permission::File,
            Permission::Restart,
            Permission::Recording,
        ];
    }

    impl ::protobuf::EnumFull for Permission {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PermissionInfo.Permission").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Permission::Keyboard => 0,
                Permission::Clipboard => 1,
                Permission::Audio => 2,
                Permission::File => 3,
                Permission::Restart => 4,
                Permission::Recording => 5,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Permission {
        fn default() -> Self {
            Permission::Keyboard
        }
    }

    impl Permission {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Permission>("PermissionInfo.Permission")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.VideoCodecState)
pub struct VideoCodecState {
    // message fields
    // @@protoc_insertion_point(field:hbb.VideoCodecState.score_vpx)
    pub score_vpx: i32,
    // @@protoc_insertion_point(field:hbb.VideoCodecState.score_h264)
    pub score_h264: i32,
    // @@protoc_insertion_point(field:hbb.VideoCodecState.score_h265)
    pub score_h265: i32,
    // @@protoc_insertion_point(field:hbb.VideoCodecState.prefer)
    pub prefer: ::protobuf::EnumOrUnknown<video_codec_state::PreferCodec>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.VideoCodecState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoCodecState {
    fn default() -> &'a VideoCodecState {
        <VideoCodecState as ::protobuf::Message>::default_instance()
    }
}

impl VideoCodecState {
    pub fn new() -> VideoCodecState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score_vpx",
            |m: &VideoCodecState| { &m.score_vpx },
            |m: &mut VideoCodecState| { &mut m.score_vpx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score_h264",
            |m: &VideoCodecState| { &m.score_h264 },
            |m: &mut VideoCodecState| { &mut m.score_h264 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score_h265",
            |m: &VideoCodecState| { &m.score_h265 },
            |m: &mut VideoCodecState| { &mut m.score_h265 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefer",
            |m: &VideoCodecState| { &m.prefer },
            |m: &mut VideoCodecState| { &mut m.prefer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoCodecState>(
            "VideoCodecState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoCodecState {
    const NAME: &'static str = "VideoCodecState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.score_vpx = is.read_int32()?;
                },
                16 => {
                    self.score_h264 = is.read_int32()?;
                },
                24 => {
                    self.score_h265 = is.read_int32()?;
                },
                32 => {
                    self.prefer = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.score_vpx != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.score_vpx);
        }
        if self.score_h264 != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.score_h264);
        }
        if self.score_h265 != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.score_h265);
        }
        if self.prefer != ::protobuf::EnumOrUnknown::new(video_codec_state::PreferCodec::Auto) {
            my_size += ::protobuf::rt::int32_size(4, self.prefer.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.score_vpx != 0 {
            os.write_int32(1, self.score_vpx)?;
        }
        if self.score_h264 != 0 {
            os.write_int32(2, self.score_h264)?;
        }
        if self.score_h265 != 0 {
            os.write_int32(3, self.score_h265)?;
        }
        if self.prefer != ::protobuf::EnumOrUnknown::new(video_codec_state::PreferCodec::Auto) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.prefer))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoCodecState {
        VideoCodecState::new()
    }

    fn clear(&mut self) {
        self.score_vpx = 0;
        self.score_h264 = 0;
        self.score_h265 = 0;
        self.prefer = ::protobuf::EnumOrUnknown::new(video_codec_state::PreferCodec::Auto);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoCodecState {
        static instance: VideoCodecState = VideoCodecState {
            score_vpx: 0,
            score_h264: 0,
            score_h265: 0,
            prefer: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoCodecState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoCodecState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoCodecState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoCodecState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VideoCodecState`
pub mod video_codec_state {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.VideoCodecState.PreferCodec)
    pub enum PreferCodec {
        // @@protoc_insertion_point(enum_value:hbb.VideoCodecState.PreferCodec.Auto)
        Auto = 0,
        // @@protoc_insertion_point(enum_value:hbb.VideoCodecState.PreferCodec.VPX)
        VPX = 1,
        // @@protoc_insertion_point(enum_value:hbb.VideoCodecState.PreferCodec.H264)
        H264 = 2,
        // @@protoc_insertion_point(enum_value:hbb.VideoCodecState.PreferCodec.H265)
        H265 = 3,
    }

    impl ::protobuf::Enum for PreferCodec {
        const NAME: &'static str = "PreferCodec";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PreferCodec> {
            match value {
                0 => ::std::option::Option::Some(PreferCodec::Auto),
                1 => ::std::option::Option::Some(PreferCodec::VPX),
                2 => ::std::option::Option::Some(PreferCodec::H264),
                3 => ::std::option::Option::Some(PreferCodec::H265),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PreferCodec] = &[
            PreferCodec::Auto,
            PreferCodec::VPX,
            PreferCodec::H264,
            PreferCodec::H265,
        ];
    }

    impl ::protobuf::EnumFull for PreferCodec {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VideoCodecState.PreferCodec").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PreferCodec {
        fn default() -> Self {
            PreferCodec::Auto
        }
    }

    impl PreferCodec {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PreferCodec>("VideoCodecState.PreferCodec")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.OptionMessage)
pub struct OptionMessage {
    // message fields
    // @@protoc_insertion_point(field:hbb.OptionMessage.image_quality)
    pub image_quality: ::protobuf::EnumOrUnknown<ImageQuality>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.lock_after_session_end)
    pub lock_after_session_end: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.show_remote_cursor)
    pub show_remote_cursor: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.privacy_mode)
    pub privacy_mode: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.block_input)
    pub block_input: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.custom_image_quality)
    pub custom_image_quality: i32,
    // @@protoc_insertion_point(field:hbb.OptionMessage.disable_audio)
    pub disable_audio: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.disable_clipboard)
    pub disable_clipboard: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.enable_file_transfer)
    pub enable_file_transfer: ::protobuf::EnumOrUnknown<option_message::BoolOption>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.video_codec_state)
    pub video_codec_state: ::protobuf::MessageField<VideoCodecState>,
    // @@protoc_insertion_point(field:hbb.OptionMessage.custom_fps)
    pub custom_fps: i32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.OptionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OptionMessage {
    fn default() -> &'a OptionMessage {
        <OptionMessage as ::protobuf::Message>::default_instance()
    }
}

impl OptionMessage {
    pub fn new() -> OptionMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_quality",
            |m: &OptionMessage| { &m.image_quality },
            |m: &mut OptionMessage| { &mut m.image_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lock_after_session_end",
            |m: &OptionMessage| { &m.lock_after_session_end },
            |m: &mut OptionMessage| { &mut m.lock_after_session_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show_remote_cursor",
            |m: &OptionMessage| { &m.show_remote_cursor },
            |m: &mut OptionMessage| { &mut m.show_remote_cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "privacy_mode",
            |m: &OptionMessage| { &m.privacy_mode },
            |m: &mut OptionMessage| { &mut m.privacy_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_input",
            |m: &OptionMessage| { &m.block_input },
            |m: &mut OptionMessage| { &mut m.block_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_image_quality",
            |m: &OptionMessage| { &m.custom_image_quality },
            |m: &mut OptionMessage| { &mut m.custom_image_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_audio",
            |m: &OptionMessage| { &m.disable_audio },
            |m: &mut OptionMessage| { &mut m.disable_audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_clipboard",
            |m: &OptionMessage| { &m.disable_clipboard },
            |m: &mut OptionMessage| { &mut m.disable_clipboard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enable_file_transfer",
            |m: &OptionMessage| { &m.enable_file_transfer },
            |m: &mut OptionMessage| { &mut m.enable_file_transfer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VideoCodecState>(
            "video_codec_state",
            |m: &OptionMessage| { &m.video_codec_state },
            |m: &mut OptionMessage| { &mut m.video_codec_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_fps",
            |m: &OptionMessage| { &m.custom_fps },
            |m: &mut OptionMessage| { &mut m.custom_fps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptionMessage>(
            "OptionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OptionMessage {
    const NAME: &'static str = "OptionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.image_quality = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.lock_after_session_end = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.show_remote_cursor = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.privacy_mode = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.block_input = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.custom_image_quality = is.read_int32()?;
                },
                56 => {
                    self.disable_audio = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.disable_clipboard = is.read_enum_or_unknown()?;
                },
                72 => {
                    self.enable_file_transfer = is.read_enum_or_unknown()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.video_codec_state)?;
                },
                88 => {
                    self.custom_fps = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.image_quality != ::protobuf::EnumOrUnknown::new(ImageQuality::NotSet) {
            my_size += ::protobuf::rt::int32_size(1, self.image_quality.value());
        }
        if self.lock_after_session_end != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(2, self.lock_after_session_end.value());
        }
        if self.show_remote_cursor != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(3, self.show_remote_cursor.value());
        }
        if self.privacy_mode != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(4, self.privacy_mode.value());
        }
        if self.block_input != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(5, self.block_input.value());
        }
        if self.custom_image_quality != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.custom_image_quality);
        }
        if self.disable_audio != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(7, self.disable_audio.value());
        }
        if self.disable_clipboard != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(8, self.disable_clipboard.value());
        }
        if self.enable_file_transfer != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            my_size += ::protobuf::rt::int32_size(9, self.enable_file_transfer.value());
        }
        if let Some(v) = self.video_codec_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.custom_fps != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.custom_fps);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.image_quality != ::protobuf::EnumOrUnknown::new(ImageQuality::NotSet) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.image_quality))?;
        }
        if self.lock_after_session_end != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.lock_after_session_end))?;
        }
        if self.show_remote_cursor != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.show_remote_cursor))?;
        }
        if self.privacy_mode != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.privacy_mode))?;
        }
        if self.block_input != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.block_input))?;
        }
        if self.custom_image_quality != 0 {
            os.write_int32(6, self.custom_image_quality)?;
        }
        if self.disable_audio != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.disable_audio))?;
        }
        if self.disable_clipboard != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.disable_clipboard))?;
        }
        if self.enable_file_transfer != ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.enable_file_transfer))?;
        }
        if let Some(v) = self.video_codec_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.custom_fps != 0 {
            os.write_int32(11, self.custom_fps)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OptionMessage {
        OptionMessage::new()
    }

    fn clear(&mut self) {
        self.image_quality = ::protobuf::EnumOrUnknown::new(ImageQuality::NotSet);
        self.lock_after_session_end = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.show_remote_cursor = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.privacy_mode = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.block_input = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.custom_image_quality = 0;
        self.disable_audio = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.disable_clipboard = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.enable_file_transfer = ::protobuf::EnumOrUnknown::new(option_message::BoolOption::NotSet);
        self.video_codec_state.clear();
        self.custom_fps = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OptionMessage {
        static instance: OptionMessage = OptionMessage {
            image_quality: ::protobuf::EnumOrUnknown::from_i32(0),
            lock_after_session_end: ::protobuf::EnumOrUnknown::from_i32(0),
            show_remote_cursor: ::protobuf::EnumOrUnknown::from_i32(0),
            privacy_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            block_input: ::protobuf::EnumOrUnknown::from_i32(0),
            custom_image_quality: 0,
            disable_audio: ::protobuf::EnumOrUnknown::from_i32(0),
            disable_clipboard: ::protobuf::EnumOrUnknown::from_i32(0),
            enable_file_transfer: ::protobuf::EnumOrUnknown::from_i32(0),
            video_codec_state: ::protobuf::MessageField::none(),
            custom_fps: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OptionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OptionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OptionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OptionMessage`
pub mod option_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.OptionMessage.BoolOption)
    pub enum BoolOption {
        // @@protoc_insertion_point(enum_value:hbb.OptionMessage.BoolOption.NotSet)
        NotSet = 0,
        // @@protoc_insertion_point(enum_value:hbb.OptionMessage.BoolOption.No)
        No = 1,
        // @@protoc_insertion_point(enum_value:hbb.OptionMessage.BoolOption.Yes)
        Yes = 2,
    }

    impl ::protobuf::Enum for BoolOption {
        const NAME: &'static str = "BoolOption";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BoolOption> {
            match value {
                0 => ::std::option::Option::Some(BoolOption::NotSet),
                1 => ::std::option::Option::Some(BoolOption::No),
                2 => ::std::option::Option::Some(BoolOption::Yes),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BoolOption] = &[
            BoolOption::NotSet,
            BoolOption::No,
            BoolOption::Yes,
        ];
    }

    impl ::protobuf::EnumFull for BoolOption {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OptionMessage.BoolOption").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BoolOption {
        fn default() -> Self {
            BoolOption::NotSet
        }
    }

    impl BoolOption {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BoolOption>("OptionMessage.BoolOption")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.TestDelay)
pub struct TestDelay {
    // message fields
    // @@protoc_insertion_point(field:hbb.TestDelay.time)
    pub time: i64,
    // @@protoc_insertion_point(field:hbb.TestDelay.from_client)
    pub from_client: bool,
    // @@protoc_insertion_point(field:hbb.TestDelay.last_delay)
    pub last_delay: u32,
    // @@protoc_insertion_point(field:hbb.TestDelay.target_bitrate)
    pub target_bitrate: u32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.TestDelay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestDelay {
    fn default() -> &'a TestDelay {
        <TestDelay as ::protobuf::Message>::default_instance()
    }
}

impl TestDelay {
    pub fn new() -> TestDelay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &TestDelay| { &m.time },
            |m: &mut TestDelay| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from_client",
            |m: &TestDelay| { &m.from_client },
            |m: &mut TestDelay| { &mut m.from_client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_delay",
            |m: &TestDelay| { &m.last_delay },
            |m: &mut TestDelay| { &mut m.last_delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_bitrate",
            |m: &TestDelay| { &m.target_bitrate },
            |m: &mut TestDelay| { &mut m.target_bitrate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestDelay>(
            "TestDelay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestDelay {
    const NAME: &'static str = "TestDelay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time = is.read_int64()?;
                },
                16 => {
                    self.from_client = is.read_bool()?;
                },
                24 => {
                    self.last_delay = is.read_uint32()?;
                },
                32 => {
                    self.target_bitrate = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.time != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.time);
        }
        if self.from_client != false {
            my_size += 1 + 1;
        }
        if self.last_delay != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.last_delay);
        }
        if self.target_bitrate != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.target_bitrate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.time != 0 {
            os.write_int64(1, self.time)?;
        }
        if self.from_client != false {
            os.write_bool(2, self.from_client)?;
        }
        if self.last_delay != 0 {
            os.write_uint32(3, self.last_delay)?;
        }
        if self.target_bitrate != 0 {
            os.write_uint32(4, self.target_bitrate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestDelay {
        TestDelay::new()
    }

    fn clear(&mut self) {
        self.time = 0;
        self.from_client = false;
        self.last_delay = 0;
        self.target_bitrate = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestDelay {
        static instance: TestDelay = TestDelay {
            time: 0,
            from_client: false,
            last_delay: 0,
            target_bitrate: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TestDelay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestDelay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestDelay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestDelay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.PublicKey)
pub struct PublicKey {
    // message fields
    // @@protoc_insertion_point(field:hbb.PublicKey.asymmetric_value)
    pub asymmetric_value: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.PublicKey.symmetric_value)
    pub symmetric_value: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.PublicKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKey {
    fn default() -> &'a PublicKey {
        <PublicKey as ::protobuf::Message>::default_instance()
    }
}

impl PublicKey {
    pub fn new() -> PublicKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asymmetric_value",
            |m: &PublicKey| { &m.asymmetric_value },
            |m: &mut PublicKey| { &mut m.asymmetric_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "symmetric_value",
            |m: &PublicKey| { &m.symmetric_value },
            |m: &mut PublicKey| { &mut m.symmetric_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PublicKey>(
            "PublicKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PublicKey {
    const NAME: &'static str = "PublicKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.asymmetric_value = is.read_tokio_bytes()?;
                },
                18 => {
                    self.symmetric_value = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.asymmetric_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.asymmetric_value);
        }
        if !self.symmetric_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.symmetric_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.asymmetric_value.is_empty() {
            os.write_bytes(1, &self.asymmetric_value)?;
        }
        if !self.symmetric_value.is_empty() {
            os.write_bytes(2, &self.symmetric_value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKey {
        PublicKey::new()
    }

    fn clear(&mut self) {
        self.asymmetric_value.clear();
        self.symmetric_value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKey {
        static instance: PublicKey = PublicKey {
            asymmetric_value: ::bytes::Bytes::new(),
            symmetric_value: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PublicKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PublicKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.SignedId)
pub struct SignedId {
    // message fields
    // @@protoc_insertion_point(field:hbb.SignedId.id)
    pub id: ::bytes::Bytes,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.SignedId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignedId {
    fn default() -> &'a SignedId {
        <SignedId as ::protobuf::Message>::default_instance()
    }
}

impl SignedId {
    pub fn new() -> SignedId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SignedId| { &m.id },
            |m: &mut SignedId| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignedId>(
            "SignedId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignedId {
    const NAME: &'static str = "SignedId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_tokio_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignedId {
        SignedId::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignedId {
        static instance: SignedId = SignedId {
            id: ::bytes::Bytes::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignedId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignedId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignedId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.AudioFormat)
pub struct AudioFormat {
    // message fields
    // @@protoc_insertion_point(field:hbb.AudioFormat.sample_rate)
    pub sample_rate: u32,
    // @@protoc_insertion_point(field:hbb.AudioFormat.channels)
    pub channels: u32,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.AudioFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioFormat {
    fn default() -> &'a AudioFormat {
        <AudioFormat as ::protobuf::Message>::default_instance()
    }
}

impl AudioFormat {
    pub fn new() -> AudioFormat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_rate",
            |m: &AudioFormat| { &m.sample_rate },
            |m: &mut AudioFormat| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channels",
            |m: &AudioFormat| { &m.channels },
            |m: &mut AudioFormat| { &mut m.channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFormat>(
            "AudioFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioFormat {
    const NAME: &'static str = "AudioFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sample_rate = is.read_uint32()?;
                },
                16 => {
                    self.channels = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sample_rate != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sample_rate);
        }
        if self.channels != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.channels);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sample_rate != 0 {
            os.write_uint32(1, self.sample_rate)?;
        }
        if self.channels != 0 {
            os.write_uint32(2, self.channels)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioFormat {
        AudioFormat::new()
    }

    fn clear(&mut self) {
        self.sample_rate = 0;
        self.channels = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioFormat {
        static instance: AudioFormat = AudioFormat {
            sample_rate: 0,
            channels: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.AudioFrame)
pub struct AudioFrame {
    // message fields
    // @@protoc_insertion_point(field:hbb.AudioFrame.data)
    pub data: ::bytes::Bytes,
    // @@protoc_insertion_point(field:hbb.AudioFrame.timestamp)
    pub timestamp: i64,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.AudioFrame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioFrame {
    fn default() -> &'a AudioFrame {
        <AudioFrame as ::protobuf::Message>::default_instance()
    }
}

impl AudioFrame {
    pub fn new() -> AudioFrame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &AudioFrame| { &m.data },
            |m: &mut AudioFrame| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &AudioFrame| { &m.timestamp },
            |m: &mut AudioFrame| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioFrame>(
            "AudioFrame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioFrame {
    const NAME: &'static str = "AudioFrame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_tokio_bytes()?;
                },
                16 => {
                    self.timestamp = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.timestamp != 0 {
            os.write_int64(2, self.timestamp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioFrame {
        AudioFrame::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioFrame {
        static instance: AudioFrame = AudioFrame {
            data: ::bytes::Bytes::new(),
            timestamp: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioFrame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioFrame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioFrame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.MessageBox)
pub struct MessageBox {
    // message fields
    // @@protoc_insertion_point(field:hbb.MessageBox.msgtype)
    pub msgtype: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.MessageBox.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.MessageBox.text)
    pub text: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.MessageBox.link)
    pub link: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.MessageBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageBox {
    fn default() -> &'a MessageBox {
        <MessageBox as ::protobuf::Message>::default_instance()
    }
}

impl MessageBox {
    pub fn new() -> MessageBox {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msgtype",
            |m: &MessageBox| { &m.msgtype },
            |m: &mut MessageBox| { &mut m.msgtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &MessageBox| { &m.title },
            |m: &mut MessageBox| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &MessageBox| { &m.text },
            |m: &mut MessageBox| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "link",
            |m: &MessageBox| { &m.link },
            |m: &mut MessageBox| { &mut m.link },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageBox>(
            "MessageBox",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageBox {
    const NAME: &'static str = "MessageBox";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.msgtype = is.read_string()?;
                },
                18 => {
                    self.title = is.read_string()?;
                },
                26 => {
                    self.text = is.read_string()?;
                },
                34 => {
                    self.link = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.msgtype.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.msgtype);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.text);
        }
        if !self.link.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.link);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.msgtype.is_empty() {
            os.write_string(1, &self.msgtype)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.text.is_empty() {
            os.write_string(3, &self.text)?;
        }
        if !self.link.is_empty() {
            os.write_string(4, &self.link)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageBox {
        MessageBox::new()
    }

    fn clear(&mut self) {
        self.msgtype.clear();
        self.title.clear();
        self.text.clear();
        self.link.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageBox {
        static instance: MessageBox = MessageBox {
            msgtype: ::std::string::String::new(),
            title: ::std::string::String::new(),
            text: ::std::string::String::new(),
            link: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageBox {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageBox").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageBox {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.BackNotification)
pub struct BackNotification {
    // message oneof groups
    pub union: ::std::option::Option<back_notification::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.BackNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BackNotification {
    fn default() -> &'a BackNotification {
        <BackNotification as ::protobuf::Message>::default_instance()
    }
}

impl BackNotification {
    pub fn new() -> BackNotification {
        ::std::default::Default::default()
    }

    // .hbb.BackNotification.PrivacyModeState privacy_mode_state = 1;

    pub fn privacy_mode_state(&self) -> back_notification::PrivacyModeState {
        match self.union {
            ::std::option::Option::Some(back_notification::Union::PrivacyModeState(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => back_notification::PrivacyModeState::PrvStateUnknown,
        }
    }

    pub fn clear_privacy_mode_state(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_privacy_mode_state(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(back_notification::Union::PrivacyModeState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_privacy_mode_state(&mut self, v: back_notification::PrivacyModeState) {
        self.union = ::std::option::Option::Some(back_notification::Union::PrivacyModeState(::protobuf::EnumOrUnknown::new(v)))
    }

    // .hbb.BackNotification.BlockInputState block_input_state = 2;

    pub fn block_input_state(&self) -> back_notification::BlockInputState {
        match self.union {
            ::std::option::Option::Some(back_notification::Union::BlockInputState(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => back_notification::BlockInputState::BlkStateUnknown,
        }
    }

    pub fn clear_block_input_state(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_block_input_state(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(back_notification::Union::BlockInputState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_input_state(&mut self, v: back_notification::BlockInputState) {
        self.union = ::std::option::Option::Some(back_notification::Union::BlockInputState(::protobuf::EnumOrUnknown::new(v)))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "privacy_mode_state",
            |message: &BackNotification| match &message.union {
                ::std::option::Option::Some(back_notification::Union::PrivacyModeState(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut BackNotification, e: ::protobuf::EnumOrUnknown<back_notification::PrivacyModeState>| {
                message.union = ::std::option::Option::Some(back_notification::Union::PrivacyModeState(e));
            },
            back_notification::PrivacyModeState::PrvStateUnknown,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "block_input_state",
            |message: &BackNotification| match &message.union {
                ::std::option::Option::Some(back_notification::Union::BlockInputState(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut BackNotification, e: ::protobuf::EnumOrUnknown<back_notification::BlockInputState>| {
                message.union = ::std::option::Option::Some(back_notification::Union::BlockInputState(e));
            },
            back_notification::BlockInputState::BlkStateUnknown,
        ));
        oneofs.push(back_notification::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BackNotification>(
            "BackNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BackNotification {
    const NAME: &'static str = "BackNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.union = ::std::option::Option::Some(back_notification::Union::PrivacyModeState(is.read_enum_or_unknown()?));
                },
                16 => {
                    self.union = ::std::option::Option::Some(back_notification::Union::BlockInputState(is.read_enum_or_unknown()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &back_notification::Union::PrivacyModeState(v) => {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                },
                &back_notification::Union::BlockInputState(v) => {
                    my_size += ::protobuf::rt::int32_size(2, v.value());
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &back_notification::Union::PrivacyModeState(v) => {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &back_notification::Union::BlockInputState(v) => {
                    os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BackNotification {
        BackNotification::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BackNotification {
        static instance: BackNotification = BackNotification {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BackNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BackNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BackNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BackNotification`
pub mod back_notification {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.BackNotification.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.BackNotification.privacy_mode_state)
        PrivacyModeState(::protobuf::EnumOrUnknown<PrivacyModeState>),
        // @@protoc_insertion_point(oneof_field:hbb.BackNotification.block_input_state)
        BlockInputState(::protobuf::EnumOrUnknown<BlockInputState>),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BackNotification as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.BackNotification.BlockInputState)
    pub enum BlockInputState {
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkStateUnknown)
        BlkStateUnknown = 0,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkOnSucceeded)
        BlkOnSucceeded = 2,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkOnFailed)
        BlkOnFailed = 3,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkOffSucceeded)
        BlkOffSucceeded = 4,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.BlockInputState.BlkOffFailed)
        BlkOffFailed = 5,
    }

    impl ::protobuf::Enum for BlockInputState {
        const NAME: &'static str = "BlockInputState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BlockInputState> {
            match value {
                0 => ::std::option::Option::Some(BlockInputState::BlkStateUnknown),
                2 => ::std::option::Option::Some(BlockInputState::BlkOnSucceeded),
                3 => ::std::option::Option::Some(BlockInputState::BlkOnFailed),
                4 => ::std::option::Option::Some(BlockInputState::BlkOffSucceeded),
                5 => ::std::option::Option::Some(BlockInputState::BlkOffFailed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BlockInputState] = &[
            BlockInputState::BlkStateUnknown,
            BlockInputState::BlkOnSucceeded,
            BlockInputState::BlkOnFailed,
            BlockInputState::BlkOffSucceeded,
            BlockInputState::BlkOffFailed,
        ];
    }

    impl ::protobuf::EnumFull for BlockInputState {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BackNotification.BlockInputState").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                BlockInputState::BlkStateUnknown => 0,
                BlockInputState::BlkOnSucceeded => 1,
                BlockInputState::BlkOnFailed => 2,
                BlockInputState::BlkOffSucceeded => 3,
                BlockInputState::BlkOffFailed => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BlockInputState {
        fn default() -> Self {
            BlockInputState::BlkStateUnknown
        }
    }

    impl BlockInputState {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BlockInputState>("BackNotification.BlockInputState")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:hbb.BackNotification.PrivacyModeState)
    pub enum PrivacyModeState {
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvStateUnknown)
        PrvStateUnknown = 0,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnByOther)
        PrvOnByOther = 2,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvNotSupported)
        PrvNotSupported = 3,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnSucceeded)
        PrvOnSucceeded = 4,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnFailedDenied)
        PrvOnFailedDenied = 5,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnFailedPlugin)
        PrvOnFailedPlugin = 6,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOnFailed)
        PrvOnFailed = 7,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOffSucceeded)
        PrvOffSucceeded = 8,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOffByPeer)
        PrvOffByPeer = 9,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOffFailed)
        PrvOffFailed = 10,
        // @@protoc_insertion_point(enum_value:hbb.BackNotification.PrivacyModeState.PrvOffUnknown)
        PrvOffUnknown = 11,
    }

    impl ::protobuf::Enum for PrivacyModeState {
        const NAME: &'static str = "PrivacyModeState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PrivacyModeState> {
            match value {
                0 => ::std::option::Option::Some(PrivacyModeState::PrvStateUnknown),
                2 => ::std::option::Option::Some(PrivacyModeState::PrvOnByOther),
                3 => ::std::option::Option::Some(PrivacyModeState::PrvNotSupported),
                4 => ::std::option::Option::Some(PrivacyModeState::PrvOnSucceeded),
                5 => ::std::option::Option::Some(PrivacyModeState::PrvOnFailedDenied),
                6 => ::std::option::Option::Some(PrivacyModeState::PrvOnFailedPlugin),
                7 => ::std::option::Option::Some(PrivacyModeState::PrvOnFailed),
                8 => ::std::option::Option::Some(PrivacyModeState::PrvOffSucceeded),
                9 => ::std::option::Option::Some(PrivacyModeState::PrvOffByPeer),
                10 => ::std::option::Option::Some(PrivacyModeState::PrvOffFailed),
                11 => ::std::option::Option::Some(PrivacyModeState::PrvOffUnknown),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PrivacyModeState] = &[
            PrivacyModeState::PrvStateUnknown,
            PrivacyModeState::PrvOnByOther,
            PrivacyModeState::PrvNotSupported,
            PrivacyModeState::PrvOnSucceeded,
            PrivacyModeState::PrvOnFailedDenied,
            PrivacyModeState::PrvOnFailedPlugin,
            PrivacyModeState::PrvOnFailed,
            PrivacyModeState::PrvOffSucceeded,
            PrivacyModeState::PrvOffByPeer,
            PrivacyModeState::PrvOffFailed,
            PrivacyModeState::PrvOffUnknown,
        ];
    }

    impl ::protobuf::EnumFull for PrivacyModeState {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BackNotification.PrivacyModeState").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                PrivacyModeState::PrvStateUnknown => 0,
                PrivacyModeState::PrvOnByOther => 1,
                PrivacyModeState::PrvNotSupported => 2,
                PrivacyModeState::PrvOnSucceeded => 3,
                PrivacyModeState::PrvOnFailedDenied => 4,
                PrivacyModeState::PrvOnFailedPlugin => 5,
                PrivacyModeState::PrvOnFailed => 6,
                PrivacyModeState::PrvOffSucceeded => 7,
                PrivacyModeState::PrvOffByPeer => 8,
                PrivacyModeState::PrvOffFailed => 9,
                PrivacyModeState::PrvOffUnknown => 10,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PrivacyModeState {
        fn default() -> Self {
            PrivacyModeState::PrvStateUnknown
        }
    }

    impl PrivacyModeState {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PrivacyModeState>("BackNotification.PrivacyModeState")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.ElevationRequestWithLogon)
pub struct ElevationRequestWithLogon {
    // message fields
    // @@protoc_insertion_point(field:hbb.ElevationRequestWithLogon.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:hbb.ElevationRequestWithLogon.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ElevationRequestWithLogon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ElevationRequestWithLogon {
    fn default() -> &'a ElevationRequestWithLogon {
        <ElevationRequestWithLogon as ::protobuf::Message>::default_instance()
    }
}

impl ElevationRequestWithLogon {
    pub fn new() -> ElevationRequestWithLogon {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &ElevationRequestWithLogon| { &m.username },
            |m: &mut ElevationRequestWithLogon| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &ElevationRequestWithLogon| { &m.password },
            |m: &mut ElevationRequestWithLogon| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ElevationRequestWithLogon>(
            "ElevationRequestWithLogon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ElevationRequestWithLogon {
    const NAME: &'static str = "ElevationRequestWithLogon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                18 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ElevationRequestWithLogon {
        ElevationRequestWithLogon::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ElevationRequestWithLogon {
        static instance: ElevationRequestWithLogon = ElevationRequestWithLogon {
            username: ::std::string::String::new(),
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ElevationRequestWithLogon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ElevationRequestWithLogon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ElevationRequestWithLogon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ElevationRequestWithLogon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.ElevationRequest)
pub struct ElevationRequest {
    // message oneof groups
    pub union: ::std::option::Option<elevation_request::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.ElevationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ElevationRequest {
    fn default() -> &'a ElevationRequest {
        <ElevationRequest as ::protobuf::Message>::default_instance()
    }
}

impl ElevationRequest {
    pub fn new() -> ElevationRequest {
        ::std::default::Default::default()
    }

    // bool direct = 1;

    pub fn direct(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Direct(v)) => v,
            _ => false,
        }
    }

    pub fn clear_direct(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_direct(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Direct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(elevation_request::Union::Direct(v))
    }

    // .hbb.ElevationRequestWithLogon logon = 2;

    pub fn logon(&self) -> &ElevationRequestWithLogon {
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Logon(ref v)) => v,
            _ => <ElevationRequestWithLogon as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_logon(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_logon(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Logon(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_logon(&mut self, v: ElevationRequestWithLogon) {
        self.union = ::std::option::Option::Some(elevation_request::Union::Logon(v))
    }

    // Mutable pointer to the field.
    pub fn mut_logon(&mut self) -> &mut ElevationRequestWithLogon {
        if let ::std::option::Option::Some(elevation_request::Union::Logon(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(elevation_request::Union::Logon(ElevationRequestWithLogon::new()));
        }
        match self.union {
            ::std::option::Option::Some(elevation_request::Union::Logon(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_logon(&mut self) -> ElevationRequestWithLogon {
        if self.has_logon() {
            match self.union.take() {
                ::std::option::Option::Some(elevation_request::Union::Logon(v)) => v,
                _ => panic!(),
            }
        } else {
            ElevationRequestWithLogon::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "direct",
            ElevationRequest::has_direct,
            ElevationRequest::direct,
            ElevationRequest::set_direct,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ElevationRequestWithLogon>(
            "logon",
            ElevationRequest::has_logon,
            ElevationRequest::logon,
            ElevationRequest::mut_logon,
            ElevationRequest::set_logon,
        ));
        oneofs.push(elevation_request::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ElevationRequest>(
            "ElevationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ElevationRequest {
    const NAME: &'static str = "ElevationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.union = ::std::option::Option::Some(elevation_request::Union::Direct(is.read_bool()?));
                },
                18 => {
                    self.union = ::std::option::Option::Some(elevation_request::Union::Logon(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &elevation_request::Union::Direct(v) => {
                    my_size += 1 + 1;
                },
                &elevation_request::Union::Logon(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &elevation_request::Union::Direct(v) => {
                    os.write_bool(1, v)?;
                },
                &elevation_request::Union::Logon(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ElevationRequest {
        ElevationRequest::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ElevationRequest {
        static instance: ElevationRequest = ElevationRequest {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ElevationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ElevationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ElevationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ElevationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ElevationRequest`
pub mod elevation_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.ElevationRequest.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.ElevationRequest.direct)
        Direct(bool),
        // @@protoc_insertion_point(oneof_field:hbb.ElevationRequest.logon)
        Logon(super::ElevationRequestWithLogon),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ElevationRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.Misc)
pub struct Misc {
    // message oneof groups
    pub union: ::std::option::Option<misc::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Misc.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Misc {
    fn default() -> &'a Misc {
        <Misc as ::protobuf::Message>::default_instance()
    }
}

impl Misc {
    pub fn new() -> Misc {
        ::std::default::Default::default()
    }

    // .hbb.ChatMessage chat_message = 4;

    pub fn chat_message(&self) -> &ChatMessage {
        match self.union {
            ::std::option::Option::Some(misc::Union::ChatMessage(ref v)) => v,
            _ => <ChatMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_chat_message(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_chat_message(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ChatMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chat_message(&mut self, v: ChatMessage) {
        self.union = ::std::option::Option::Some(misc::Union::ChatMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chat_message(&mut self) -> &mut ChatMessage {
        if let ::std::option::Option::Some(misc::Union::ChatMessage(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ChatMessage(ChatMessage::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ChatMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chat_message(&mut self) -> ChatMessage {
        if self.has_chat_message() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ChatMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ChatMessage::new()
        }
    }

    // .hbb.SwitchDisplay switch_display = 5;

    pub fn switch_display(&self) -> &SwitchDisplay {
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchDisplay(ref v)) => v,
            _ => <SwitchDisplay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_switch_display(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_switch_display(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchDisplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_switch_display(&mut self, v: SwitchDisplay) {
        self.union = ::std::option::Option::Some(misc::Union::SwitchDisplay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_switch_display(&mut self) -> &mut SwitchDisplay {
        if let ::std::option::Option::Some(misc::Union::SwitchDisplay(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::SwitchDisplay(SwitchDisplay::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::SwitchDisplay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_switch_display(&mut self) -> SwitchDisplay {
        if self.has_switch_display() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::SwitchDisplay(v)) => v,
                _ => panic!(),
            }
        } else {
            SwitchDisplay::new()
        }
    }

    // .hbb.PermissionInfo permission_info = 6;

    pub fn permission_info(&self) -> &PermissionInfo {
        match self.union {
            ::std::option::Option::Some(misc::Union::PermissionInfo(ref v)) => v,
            _ => <PermissionInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_permission_info(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_permission_info(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::PermissionInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_permission_info(&mut self, v: PermissionInfo) {
        self.union = ::std::option::Option::Some(misc::Union::PermissionInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_permission_info(&mut self) -> &mut PermissionInfo {
        if let ::std::option::Option::Some(misc::Union::PermissionInfo(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::PermissionInfo(PermissionInfo::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::PermissionInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_permission_info(&mut self) -> PermissionInfo {
        if self.has_permission_info() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::PermissionInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            PermissionInfo::new()
        }
    }

    // .hbb.OptionMessage option = 7;

    pub fn option(&self) -> &OptionMessage {
        match self.union {
            ::std::option::Option::Some(misc::Union::Option(ref v)) => v,
            _ => <OptionMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_option(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_option(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::Option(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_option(&mut self, v: OptionMessage) {
        self.union = ::std::option::Option::Some(misc::Union::Option(v))
    }

    // Mutable pointer to the field.
    pub fn mut_option(&mut self) -> &mut OptionMessage {
        if let ::std::option::Option::Some(misc::Union::Option(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::Option(OptionMessage::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::Option(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_option(&mut self) -> OptionMessage {
        if self.has_option() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::Option(v)) => v,
                _ => panic!(),
            }
        } else {
            OptionMessage::new()
        }
    }

    // .hbb.AudioFormat audio_format = 8;

    pub fn audio_format(&self) -> &AudioFormat {
        match self.union {
            ::std::option::Option::Some(misc::Union::AudioFormat(ref v)) => v,
            _ => <AudioFormat as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_audio_format(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_audio_format(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::AudioFormat(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_format(&mut self, v: AudioFormat) {
        self.union = ::std::option::Option::Some(misc::Union::AudioFormat(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_format(&mut self) -> &mut AudioFormat {
        if let ::std::option::Option::Some(misc::Union::AudioFormat(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::AudioFormat(AudioFormat::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::AudioFormat(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_format(&mut self) -> AudioFormat {
        if self.has_audio_format() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::AudioFormat(v)) => v,
                _ => panic!(),
            }
        } else {
            AudioFormat::new()
        }
    }

    // string close_reason = 9;

    pub fn close_reason(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(misc::Union::CloseReason(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_close_reason(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::CloseReason(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(misc::Union::CloseReason(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_reason(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(misc::Union::CloseReason(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::CloseReason(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::CloseReason(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_reason(&mut self) -> ::std::string::String {
        if self.has_close_reason() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::CloseReason(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool refresh_video = 10;

    pub fn refresh_video(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RefreshVideo(v)) => v,
            _ => false,
        }
    }

    pub fn clear_refresh_video(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_refresh_video(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RefreshVideo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_refresh_video(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::RefreshVideo(v))
    }

    // bool video_received = 12;

    pub fn video_received(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::VideoReceived(v)) => v,
            _ => false,
        }
    }

    pub fn clear_video_received(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_video_received(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::VideoReceived(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_video_received(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::VideoReceived(v))
    }

    // .hbb.BackNotification back_notification = 13;

    pub fn back_notification(&self) -> &BackNotification {
        match self.union {
            ::std::option::Option::Some(misc::Union::BackNotification(ref v)) => v,
            _ => <BackNotification as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_back_notification(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_back_notification(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::BackNotification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_back_notification(&mut self, v: BackNotification) {
        self.union = ::std::option::Option::Some(misc::Union::BackNotification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_back_notification(&mut self) -> &mut BackNotification {
        if let ::std::option::Option::Some(misc::Union::BackNotification(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::BackNotification(BackNotification::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::BackNotification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_back_notification(&mut self) -> BackNotification {
        if self.has_back_notification() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::BackNotification(v)) => v,
                _ => panic!(),
            }
        } else {
            BackNotification::new()
        }
    }

    // bool restart_remote_device = 14;

    pub fn restart_remote_device(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RestartRemoteDevice(v)) => v,
            _ => false,
        }
    }

    pub fn clear_restart_remote_device(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_restart_remote_device(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::RestartRemoteDevice(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_restart_remote_device(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::RestartRemoteDevice(v))
    }

    // bool uac = 15;

    pub fn uac(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::Uac(v)) => v,
            _ => false,
        }
    }

    pub fn clear_uac(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_uac(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::Uac(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uac(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::Uac(v))
    }

    // bool foreground_window_elevated = 16;

    pub fn foreground_window_elevated(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ForegroundWindowElevated(v)) => v,
            _ => false,
        }
    }

    pub fn clear_foreground_window_elevated(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_foreground_window_elevated(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ForegroundWindowElevated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_foreground_window_elevated(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::ForegroundWindowElevated(v))
    }

    // bool stop_service = 17;

    pub fn stop_service(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::StopService(v)) => v,
            _ => false,
        }
    }

    pub fn clear_stop_service(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_stop_service(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::StopService(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop_service(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::StopService(v))
    }

    // .hbb.ElevationRequest elevation_request = 18;

    pub fn elevation_request(&self) -> &ElevationRequest {
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationRequest(ref v)) => v,
            _ => <ElevationRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_elevation_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_elevation_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_elevation_request(&mut self, v: ElevationRequest) {
        self.union = ::std::option::Option::Some(misc::Union::ElevationRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_elevation_request(&mut self) -> &mut ElevationRequest {
        if let ::std::option::Option::Some(misc::Union::ElevationRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ElevationRequest(ElevationRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_elevation_request(&mut self) -> ElevationRequest {
        if self.has_elevation_request() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ElevationRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            ElevationRequest::new()
        }
    }

    // string elevation_response = 19;

    pub fn elevation_response(&self) -> &str {
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationResponse(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_elevation_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_elevation_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_elevation_response(&mut self, v: ::std::string::String) {
        self.union = ::std::option::Option::Some(misc::Union::ElevationResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_elevation_response(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(misc::Union::ElevationResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(misc::Union::ElevationResponse(::std::string::String::new()));
        }
        match self.union {
            ::std::option::Option::Some(misc::Union::ElevationResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_elevation_response(&mut self) -> ::std::string::String {
        if self.has_elevation_response() {
            match self.union.take() {
                ::std::option::Option::Some(misc::Union::ElevationResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool portable_service_running = 20;

    pub fn portable_service_running(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::PortableServiceRunning(v)) => v,
            _ => false,
        }
    }

    pub fn clear_portable_service_running(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_portable_service_running(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(misc::Union::PortableServiceRunning(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_portable_service_running(&mut self, v: bool) {
        self.union = ::std::option::Option::Some(misc::Union::PortableServiceRunning(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ChatMessage>(
            "chat_message",
            Misc::has_chat_message,
            Misc::chat_message,
            Misc::mut_chat_message,
            Misc::set_chat_message,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SwitchDisplay>(
            "switch_display",
            Misc::has_switch_display,
            Misc::switch_display,
            Misc::mut_switch_display,
            Misc::set_switch_display,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PermissionInfo>(
            "permission_info",
            Misc::has_permission_info,
            Misc::permission_info,
            Misc::mut_permission_info,
            Misc::set_permission_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OptionMessage>(
            "option",
            Misc::has_option,
            Misc::option,
            Misc::mut_option,
            Misc::set_option,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AudioFormat>(
            "audio_format",
            Misc::has_audio_format,
            Misc::audio_format,
            Misc::mut_audio_format,
            Misc::set_audio_format,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "close_reason",
            Misc::has_close_reason,
            Misc::close_reason,
            Misc::set_close_reason,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "refresh_video",
            Misc::has_refresh_video,
            Misc::refresh_video,
            Misc::set_refresh_video,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "video_received",
            Misc::has_video_received,
            Misc::video_received,
            Misc::set_video_received,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BackNotification>(
            "back_notification",
            Misc::has_back_notification,
            Misc::back_notification,
            Misc::mut_back_notification,
            Misc::set_back_notification,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "restart_remote_device",
            Misc::has_restart_remote_device,
            Misc::restart_remote_device,
            Misc::set_restart_remote_device,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "uac",
            Misc::has_uac,
            Misc::uac,
            Misc::set_uac,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "foreground_window_elevated",
            Misc::has_foreground_window_elevated,
            Misc::foreground_window_elevated,
            Misc::set_foreground_window_elevated,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "stop_service",
            Misc::has_stop_service,
            Misc::stop_service,
            Misc::set_stop_service,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ElevationRequest>(
            "elevation_request",
            Misc::has_elevation_request,
            Misc::elevation_request,
            Misc::mut_elevation_request,
            Misc::set_elevation_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "elevation_response",
            Misc::has_elevation_response,
            Misc::elevation_response,
            Misc::set_elevation_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "portable_service_running",
            Misc::has_portable_service_running,
            Misc::portable_service_running,
            Misc::set_portable_service_running,
        ));
        oneofs.push(misc::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Misc>(
            "Misc",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Misc {
    const NAME: &'static str = "Misc";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.union = ::std::option::Option::Some(misc::Union::ChatMessage(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(misc::Union::SwitchDisplay(is.read_message()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(misc::Union::PermissionInfo(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(misc::Union::Option(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(misc::Union::AudioFormat(is.read_message()?));
                },
                74 => {
                    self.union = ::std::option::Option::Some(misc::Union::CloseReason(is.read_string()?));
                },
                80 => {
                    self.union = ::std::option::Option::Some(misc::Union::RefreshVideo(is.read_bool()?));
                },
                96 => {
                    self.union = ::std::option::Option::Some(misc::Union::VideoReceived(is.read_bool()?));
                },
                106 => {
                    self.union = ::std::option::Option::Some(misc::Union::BackNotification(is.read_message()?));
                },
                112 => {
                    self.union = ::std::option::Option::Some(misc::Union::RestartRemoteDevice(is.read_bool()?));
                },
                120 => {
                    self.union = ::std::option::Option::Some(misc::Union::Uac(is.read_bool()?));
                },
                128 => {
                    self.union = ::std::option::Option::Some(misc::Union::ForegroundWindowElevated(is.read_bool()?));
                },
                136 => {
                    self.union = ::std::option::Option::Some(misc::Union::StopService(is.read_bool()?));
                },
                146 => {
                    self.union = ::std::option::Option::Some(misc::Union::ElevationRequest(is.read_message()?));
                },
                154 => {
                    self.union = ::std::option::Option::Some(misc::Union::ElevationResponse(is.read_string()?));
                },
                160 => {
                    self.union = ::std::option::Option::Some(misc::Union::PortableServiceRunning(is.read_bool()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &misc::Union::ChatMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::SwitchDisplay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::PermissionInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::Option(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::AudioFormat(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::CloseReason(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
                &misc::Union::RefreshVideo(v) => {
                    my_size += 1 + 1;
                },
                &misc::Union::VideoReceived(v) => {
                    my_size += 1 + 1;
                },
                &misc::Union::BackNotification(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::RestartRemoteDevice(v) => {
                    my_size += 1 + 1;
                },
                &misc::Union::Uac(v) => {
                    my_size += 1 + 1;
                },
                &misc::Union::ForegroundWindowElevated(v) => {
                    my_size += 2 + 1;
                },
                &misc::Union::StopService(v) => {
                    my_size += 2 + 1;
                },
                &misc::Union::ElevationRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &misc::Union::ElevationResponse(ref v) => {
                    my_size += ::protobuf::rt::string_size(19, &v);
                },
                &misc::Union::PortableServiceRunning(v) => {
                    my_size += 2 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &misc::Union::ChatMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &misc::Union::SwitchDisplay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &misc::Union::PermissionInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &misc::Union::Option(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &misc::Union::AudioFormat(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &misc::Union::CloseReason(ref v) => {
                    os.write_string(9, v)?;
                },
                &misc::Union::RefreshVideo(v) => {
                    os.write_bool(10, v)?;
                },
                &misc::Union::VideoReceived(v) => {
                    os.write_bool(12, v)?;
                },
                &misc::Union::BackNotification(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &misc::Union::RestartRemoteDevice(v) => {
                    os.write_bool(14, v)?;
                },
                &misc::Union::Uac(v) => {
                    os.write_bool(15, v)?;
                },
                &misc::Union::ForegroundWindowElevated(v) => {
                    os.write_bool(16, v)?;
                },
                &misc::Union::StopService(v) => {
                    os.write_bool(17, v)?;
                },
                &misc::Union::ElevationRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &misc::Union::ElevationResponse(ref v) => {
                    os.write_string(19, v)?;
                },
                &misc::Union::PortableServiceRunning(v) => {
                    os.write_bool(20, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Misc {
        Misc::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Misc {
        static instance: Misc = Misc {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Misc {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Misc").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Misc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Misc {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Misc`
pub mod misc {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.Misc.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.Misc.chat_message)
        ChatMessage(super::ChatMessage),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.switch_display)
        SwitchDisplay(super::SwitchDisplay),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.permission_info)
        PermissionInfo(super::PermissionInfo),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.option)
        Option(super::OptionMessage),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.audio_format)
        AudioFormat(super::AudioFormat),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.close_reason)
        CloseReason(::std::string::String),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.refresh_video)
        RefreshVideo(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.video_received)
        VideoReceived(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.back_notification)
        BackNotification(super::BackNotification),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.restart_remote_device)
        RestartRemoteDevice(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.uac)
        Uac(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.foreground_window_elevated)
        ForegroundWindowElevated(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.stop_service)
        StopService(bool),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.elevation_request)
        ElevationRequest(super::ElevationRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.elevation_response)
        ElevationResponse(::std::string::String),
        // @@protoc_insertion_point(oneof_field:hbb.Misc.portable_service_running)
        PortableServiceRunning(bool),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Misc as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:hbb.Message)
pub struct Message {
    // message oneof groups
    pub union: ::std::option::Option<message::Union>,
    // special fields
    // @@protoc_insertion_point(special_field:hbb.Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .hbb.SignedId signed_id = 3;

    pub fn signed_id(&self) -> &SignedId {
        match self.union {
            ::std::option::Option::Some(message::Union::SignedId(ref v)) => v,
            _ => <SignedId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_signed_id(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_signed_id(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::SignedId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signed_id(&mut self, v: SignedId) {
        self.union = ::std::option::Option::Some(message::Union::SignedId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signed_id(&mut self) -> &mut SignedId {
        if let ::std::option::Option::Some(message::Union::SignedId(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::SignedId(SignedId::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::SignedId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signed_id(&mut self) -> SignedId {
        if self.has_signed_id() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::SignedId(v)) => v,
                _ => panic!(),
            }
        } else {
            SignedId::new()
        }
    }

    // .hbb.PublicKey public_key = 4;

    pub fn public_key(&self) -> &PublicKey {
        match self.union {
            ::std::option::Option::Some(message::Union::PublicKey(ref v)) => v,
            _ => <PublicKey as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_public_key(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_public_key(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::PublicKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: PublicKey) {
        self.union = ::std::option::Option::Some(message::Union::PublicKey(v))
    }

    // Mutable pointer to the field.
    pub fn mut_public_key(&mut self) -> &mut PublicKey {
        if let ::std::option::Option::Some(message::Union::PublicKey(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::PublicKey(PublicKey::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::PublicKey(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_public_key(&mut self) -> PublicKey {
        if self.has_public_key() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::PublicKey(v)) => v,
                _ => panic!(),
            }
        } else {
            PublicKey::new()
        }
    }

    // .hbb.TestDelay test_delay = 5;

    pub fn test_delay(&self) -> &TestDelay {
        match self.union {
            ::std::option::Option::Some(message::Union::TestDelay(ref v)) => v,
            _ => <TestDelay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_test_delay(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_test_delay(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::TestDelay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_test_delay(&mut self, v: TestDelay) {
        self.union = ::std::option::Option::Some(message::Union::TestDelay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_test_delay(&mut self) -> &mut TestDelay {
        if let ::std::option::Option::Some(message::Union::TestDelay(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::TestDelay(TestDelay::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::TestDelay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_test_delay(&mut self) -> TestDelay {
        if self.has_test_delay() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::TestDelay(v)) => v,
                _ => panic!(),
            }
        } else {
            TestDelay::new()
        }
    }

    // .hbb.VideoFrame video_frame = 6;

    pub fn video_frame(&self) -> &VideoFrame {
        match self.union {
            ::std::option::Option::Some(message::Union::VideoFrame(ref v)) => v,
            _ => <VideoFrame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_video_frame(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_video_frame(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::VideoFrame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_video_frame(&mut self, v: VideoFrame) {
        self.union = ::std::option::Option::Some(message::Union::VideoFrame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_video_frame(&mut self) -> &mut VideoFrame {
        if let ::std::option::Option::Some(message::Union::VideoFrame(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::VideoFrame(VideoFrame::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::VideoFrame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_video_frame(&mut self) -> VideoFrame {
        if self.has_video_frame() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::VideoFrame(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoFrame::new()
        }
    }

    // .hbb.LoginRequest login_request = 7;

    pub fn login_request(&self) -> &LoginRequest {
        match self.union {
            ::std::option::Option::Some(message::Union::LoginRequest(ref v)) => v,
            _ => <LoginRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_login_request(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_login_request(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::LoginRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_login_request(&mut self, v: LoginRequest) {
        self.union = ::std::option::Option::Some(message::Union::LoginRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_login_request(&mut self) -> &mut LoginRequest {
        if let ::std::option::Option::Some(message::Union::LoginRequest(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::LoginRequest(LoginRequest::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::LoginRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_login_request(&mut self) -> LoginRequest {
        if self.has_login_request() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::LoginRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            LoginRequest::new()
        }
    }

    // .hbb.LoginResponse login_response = 8;

    pub fn login_response(&self) -> &LoginResponse {
        match self.union {
            ::std::option::Option::Some(message::Union::LoginResponse(ref v)) => v,
            _ => <LoginResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_login_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_login_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::LoginResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_login_response(&mut self, v: LoginResponse) {
        self.union = ::std::option::Option::Some(message::Union::LoginResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_login_response(&mut self) -> &mut LoginResponse {
        if let ::std::option::Option::Some(message::Union::LoginResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::LoginResponse(LoginResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::LoginResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_login_response(&mut self) -> LoginResponse {
        if self.has_login_response() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::LoginResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            LoginResponse::new()
        }
    }

    // .hbb.Hash hash = 9;

    pub fn hash(&self) -> &Hash {
        match self.union {
            ::std::option::Option::Some(message::Union::Hash(ref v)) => v,
            _ => <Hash as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hash(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Hash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: Hash) {
        self.union = ::std::option::Option::Some(message::Union::Hash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hash(&mut self) -> &mut Hash {
        if let ::std::option::Option::Some(message::Union::Hash(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Hash(Hash::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Hash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hash(&mut self) -> Hash {
        if self.has_hash() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Hash(v)) => v,
                _ => panic!(),
            }
        } else {
            Hash::new()
        }
    }

    // .hbb.MouseEvent mouse_event = 10;

    pub fn mouse_event(&self) -> &MouseEvent {
        match self.union {
            ::std::option::Option::Some(message::Union::MouseEvent(ref v)) => v,
            _ => <MouseEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_event(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_mouse_event(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::MouseEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_event(&mut self, v: MouseEvent) {
        self.union = ::std::option::Option::Some(message::Union::MouseEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_event(&mut self) -> &mut MouseEvent {
        if let ::std::option::Option::Some(message::Union::MouseEvent(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::MouseEvent(MouseEvent::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::MouseEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_event(&mut self) -> MouseEvent {
        if self.has_mouse_event() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::MouseEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            MouseEvent::new()
        }
    }

    // .hbb.AudioFrame audio_frame = 11;

    pub fn audio_frame(&self) -> &AudioFrame {
        match self.union {
            ::std::option::Option::Some(message::Union::AudioFrame(ref v)) => v,
            _ => <AudioFrame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_audio_frame(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_audio_frame(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::AudioFrame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_frame(&mut self, v: AudioFrame) {
        self.union = ::std::option::Option::Some(message::Union::AudioFrame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_frame(&mut self) -> &mut AudioFrame {
        if let ::std::option::Option::Some(message::Union::AudioFrame(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::AudioFrame(AudioFrame::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::AudioFrame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_frame(&mut self) -> AudioFrame {
        if self.has_audio_frame() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::AudioFrame(v)) => v,
                _ => panic!(),
            }
        } else {
            AudioFrame::new()
        }
    }

    // .hbb.CursorData cursor_data = 12;

    pub fn cursor_data(&self) -> &CursorData {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorData(ref v)) => v,
            _ => <CursorData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cursor_data(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_data(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_data(&mut self, v: CursorData) {
        self.union = ::std::option::Option::Some(message::Union::CursorData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cursor_data(&mut self) -> &mut CursorData {
        if let ::std::option::Option::Some(message::Union::CursorData(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::CursorData(CursorData::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::CursorData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cursor_data(&mut self) -> CursorData {
        if self.has_cursor_data() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::CursorData(v)) => v,
                _ => panic!(),
            }
        } else {
            CursorData::new()
        }
    }

    // .hbb.CursorPosition cursor_position = 13;

    pub fn cursor_position(&self) -> &CursorPosition {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorPosition(ref v)) => v,
            _ => <CursorPosition as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cursor_position(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_position(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorPosition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_position(&mut self, v: CursorPosition) {
        self.union = ::std::option::Option::Some(message::Union::CursorPosition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cursor_position(&mut self) -> &mut CursorPosition {
        if let ::std::option::Option::Some(message::Union::CursorPosition(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::CursorPosition(CursorPosition::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::CursorPosition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cursor_position(&mut self) -> CursorPosition {
        if self.has_cursor_position() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::CursorPosition(v)) => v,
                _ => panic!(),
            }
        } else {
            CursorPosition::new()
        }
    }

    // uint64 cursor_id = 14;

    pub fn cursor_id(&self) -> u64 {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorId(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_cursor_id(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::CursorId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.union = ::std::option::Option::Some(message::Union::CursorId(v))
    }

    // .hbb.KeyEvent key_event = 15;

    pub fn key_event(&self) -> &KeyEvent {
        match self.union {
            ::std::option::Option::Some(message::Union::KeyEvent(ref v)) => v,
            _ => <KeyEvent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_key_event(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_key_event(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::KeyEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_event(&mut self, v: KeyEvent) {
        self.union = ::std::option::Option::Some(message::Union::KeyEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_event(&mut self) -> &mut KeyEvent {
        if let ::std::option::Option::Some(message::Union::KeyEvent(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::KeyEvent(KeyEvent::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::KeyEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_event(&mut self) -> KeyEvent {
        if self.has_key_event() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::KeyEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyEvent::new()
        }
    }

    // .hbb.Clipboard clipboard = 16;

    pub fn clipboard(&self) -> &Clipboard {
        match self.union {
            ::std::option::Option::Some(message::Union::Clipboard(ref v)) => v,
            _ => <Clipboard as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_clipboard(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_clipboard(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Clipboard(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clipboard(&mut self, v: Clipboard) {
        self.union = ::std::option::Option::Some(message::Union::Clipboard(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clipboard(&mut self) -> &mut Clipboard {
        if let ::std::option::Option::Some(message::Union::Clipboard(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Clipboard(Clipboard::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Clipboard(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clipboard(&mut self) -> Clipboard {
        if self.has_clipboard() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Clipboard(v)) => v,
                _ => panic!(),
            }
        } else {
            Clipboard::new()
        }
    }

    // .hbb.FileAction file_action = 17;

    pub fn file_action(&self) -> &FileAction {
        match self.union {
            ::std::option::Option::Some(message::Union::FileAction(ref v)) => v,
            _ => <FileAction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_action(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_action(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::FileAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_action(&mut self, v: FileAction) {
        self.union = ::std::option::Option::Some(message::Union::FileAction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_action(&mut self) -> &mut FileAction {
        if let ::std::option::Option::Some(message::Union::FileAction(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::FileAction(FileAction::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::FileAction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_action(&mut self) -> FileAction {
        if self.has_file_action() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::FileAction(v)) => v,
                _ => panic!(),
            }
        } else {
            FileAction::new()
        }
    }

    // .hbb.FileResponse file_response = 18;

    pub fn file_response(&self) -> &FileResponse {
        match self.union {
            ::std::option::Option::Some(message::Union::FileResponse(ref v)) => v,
            _ => <FileResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_file_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_file_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::FileResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file_response(&mut self, v: FileResponse) {
        self.union = ::std::option::Option::Some(message::Union::FileResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file_response(&mut self) -> &mut FileResponse {
        if let ::std::option::Option::Some(message::Union::FileResponse(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::FileResponse(FileResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::FileResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file_response(&mut self) -> FileResponse {
        if self.has_file_response() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::FileResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            FileResponse::new()
        }
    }

    // .hbb.Misc misc = 19;

    pub fn misc(&self) -> &Misc {
        match self.union {
            ::std::option::Option::Some(message::Union::Misc(ref v)) => v,
            _ => <Misc as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_misc(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_misc(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Misc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_misc(&mut self, v: Misc) {
        self.union = ::std::option::Option::Some(message::Union::Misc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_misc(&mut self) -> &mut Misc {
        if let ::std::option::Option::Some(message::Union::Misc(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Misc(Misc::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Misc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_misc(&mut self) -> Misc {
        if self.has_misc() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Misc(v)) => v,
                _ => panic!(),
            }
        } else {
            Misc::new()
        }
    }

    // .hbb.Cliprdr cliprdr = 20;

    pub fn cliprdr(&self) -> &Cliprdr {
        match self.union {
            ::std::option::Option::Some(message::Union::Cliprdr(ref v)) => v,
            _ => <Cliprdr as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cliprdr(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_cliprdr(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::Cliprdr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cliprdr(&mut self, v: Cliprdr) {
        self.union = ::std::option::Option::Some(message::Union::Cliprdr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cliprdr(&mut self) -> &mut Cliprdr {
        if let ::std::option::Option::Some(message::Union::Cliprdr(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::Cliprdr(Cliprdr::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::Cliprdr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cliprdr(&mut self) -> Cliprdr {
        if self.has_cliprdr() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::Cliprdr(v)) => v,
                _ => panic!(),
            }
        } else {
            Cliprdr::new()
        }
    }

    // .hbb.MessageBox message_box = 21;

    pub fn message_box(&self) -> &MessageBox {
        match self.union {
            ::std::option::Option::Some(message::Union::MessageBox(ref v)) => v,
            _ => <MessageBox as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_message_box(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_message_box(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(message::Union::MessageBox(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_box(&mut self, v: MessageBox) {
        self.union = ::std::option::Option::Some(message::Union::MessageBox(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_box(&mut self) -> &mut MessageBox {
        if let ::std::option::Option::Some(message::Union::MessageBox(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(message::Union::MessageBox(MessageBox::new()));
        }
        match self.union {
            ::std::option::Option::Some(message::Union::MessageBox(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_box(&mut self) -> MessageBox {
        if self.has_message_box() {
            match self.union.take() {
                ::std::option::Option::Some(message::Union::MessageBox(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageBox::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SignedId>(
            "signed_id",
            Message::has_signed_id,
            Message::signed_id,
            Message::mut_signed_id,
            Message::set_signed_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PublicKey>(
            "public_key",
            Message::has_public_key,
            Message::public_key,
            Message::mut_public_key,
            Message::set_public_key,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TestDelay>(
            "test_delay",
            Message::has_test_delay,
            Message::test_delay,
            Message::mut_test_delay,
            Message::set_test_delay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoFrame>(
            "video_frame",
            Message::has_video_frame,
            Message::video_frame,
            Message::mut_video_frame,
            Message::set_video_frame,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LoginRequest>(
            "login_request",
            Message::has_login_request,
            Message::login_request,
            Message::mut_login_request,
            Message::set_login_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LoginResponse>(
            "login_response",
            Message::has_login_response,
            Message::login_response,
            Message::mut_login_response,
            Message::set_login_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Hash>(
            "hash",
            Message::has_hash,
            Message::hash,
            Message::mut_hash,
            Message::set_hash,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MouseEvent>(
            "mouse_event",
            Message::has_mouse_event,
            Message::mouse_event,
            Message::mut_mouse_event,
            Message::set_mouse_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AudioFrame>(
            "audio_frame",
            Message::has_audio_frame,
            Message::audio_frame,
            Message::mut_audio_frame,
            Message::set_audio_frame,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CursorData>(
            "cursor_data",
            Message::has_cursor_data,
            Message::cursor_data,
            Message::mut_cursor_data,
            Message::set_cursor_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CursorPosition>(
            "cursor_position",
            Message::has_cursor_position,
            Message::cursor_position,
            Message::mut_cursor_position,
            Message::set_cursor_position,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "cursor_id",
            Message::has_cursor_id,
            Message::cursor_id,
            Message::set_cursor_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, KeyEvent>(
            "key_event",
            Message::has_key_event,
            Message::key_event,
            Message::mut_key_event,
            Message::set_key_event,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Clipboard>(
            "clipboard",
            Message::has_clipboard,
            Message::clipboard,
            Message::mut_clipboard,
            Message::set_clipboard,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileAction>(
            "file_action",
            Message::has_file_action,
            Message::file_action,
            Message::mut_file_action,
            Message::set_file_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FileResponse>(
            "file_response",
            Message::has_file_response,
            Message::file_response,
            Message::mut_file_response,
            Message::set_file_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Misc>(
            "misc",
            Message::has_misc,
            Message::misc,
            Message::mut_misc,
            Message::set_misc,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Cliprdr>(
            "cliprdr",
            Message::has_cliprdr,
            Message::cliprdr,
            Message::mut_cliprdr,
            Message::set_cliprdr,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MessageBox>(
            "message_box",
            Message::has_message_box,
            Message::message_box,
            Message::mut_message_box,
            Message::set_message_box,
        ));
        oneofs.push(message::Union::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.union = ::std::option::Option::Some(message::Union::SignedId(is.read_message()?));
                },
                34 => {
                    self.union = ::std::option::Option::Some(message::Union::PublicKey(is.read_message()?));
                },
                42 => {
                    self.union = ::std::option::Option::Some(message::Union::TestDelay(is.read_message()?));
                },
                50 => {
                    self.union = ::std::option::Option::Some(message::Union::VideoFrame(is.read_message()?));
                },
                58 => {
                    self.union = ::std::option::Option::Some(message::Union::LoginRequest(is.read_message()?));
                },
                66 => {
                    self.union = ::std::option::Option::Some(message::Union::LoginResponse(is.read_message()?));
                },
                74 => {
                    self.union = ::std::option::Option::Some(message::Union::Hash(is.read_message()?));
                },
                82 => {
                    self.union = ::std::option::Option::Some(message::Union::MouseEvent(is.read_message()?));
                },
                90 => {
                    self.union = ::std::option::Option::Some(message::Union::AudioFrame(is.read_message()?));
                },
                98 => {
                    self.union = ::std::option::Option::Some(message::Union::CursorData(is.read_message()?));
                },
                106 => {
                    self.union = ::std::option::Option::Some(message::Union::CursorPosition(is.read_message()?));
                },
                112 => {
                    self.union = ::std::option::Option::Some(message::Union::CursorId(is.read_uint64()?));
                },
                122 => {
                    self.union = ::std::option::Option::Some(message::Union::KeyEvent(is.read_message()?));
                },
                130 => {
                    self.union = ::std::option::Option::Some(message::Union::Clipboard(is.read_message()?));
                },
                138 => {
                    self.union = ::std::option::Option::Some(message::Union::FileAction(is.read_message()?));
                },
                146 => {
                    self.union = ::std::option::Option::Some(message::Union::FileResponse(is.read_message()?));
                },
                154 => {
                    self.union = ::std::option::Option::Some(message::Union::Misc(is.read_message()?));
                },
                162 => {
                    self.union = ::std::option::Option::Some(message::Union::Cliprdr(is.read_message()?));
                },
                170 => {
                    self.union = ::std::option::Option::Some(message::Union::MessageBox(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &message::Union::SignedId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::PublicKey(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::TestDelay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::VideoFrame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::LoginRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::LoginResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Hash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::MouseEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::AudioFrame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::CursorData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::CursorPosition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::CursorId(v) => {
                    my_size += ::protobuf::rt::uint64_size(14, v);
                },
                &message::Union::KeyEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Clipboard(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::FileAction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::FileResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Misc(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::Cliprdr(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message::Union::MessageBox(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &message::Union::SignedId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &message::Union::PublicKey(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &message::Union::TestDelay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &message::Union::VideoFrame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &message::Union::LoginRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &message::Union::LoginResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &message::Union::Hash(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &message::Union::MouseEvent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &message::Union::AudioFrame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &message::Union::CursorData(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &message::Union::CursorPosition(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &message::Union::CursorId(v) => {
                    os.write_uint64(14, v)?;
                },
                &message::Union::KeyEvent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &message::Union::Clipboard(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &message::Union::FileAction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &message::Union::FileResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &message::Union::Misc(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &message::Union::Cliprdr(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
                &message::Union::MessageBox(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            union: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:hbb.Message.union)
    pub enum Union {
        // @@protoc_insertion_point(oneof_field:hbb.Message.signed_id)
        SignedId(super::SignedId),
        // @@protoc_insertion_point(oneof_field:hbb.Message.public_key)
        PublicKey(super::PublicKey),
        // @@protoc_insertion_point(oneof_field:hbb.Message.test_delay)
        TestDelay(super::TestDelay),
        // @@protoc_insertion_point(oneof_field:hbb.Message.video_frame)
        VideoFrame(super::VideoFrame),
        // @@protoc_insertion_point(oneof_field:hbb.Message.login_request)
        LoginRequest(super::LoginRequest),
        // @@protoc_insertion_point(oneof_field:hbb.Message.login_response)
        LoginResponse(super::LoginResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Message.hash)
        Hash(super::Hash),
        // @@protoc_insertion_point(oneof_field:hbb.Message.mouse_event)
        MouseEvent(super::MouseEvent),
        // @@protoc_insertion_point(oneof_field:hbb.Message.audio_frame)
        AudioFrame(super::AudioFrame),
        // @@protoc_insertion_point(oneof_field:hbb.Message.cursor_data)
        CursorData(super::CursorData),
        // @@protoc_insertion_point(oneof_field:hbb.Message.cursor_position)
        CursorPosition(super::CursorPosition),
        // @@protoc_insertion_point(oneof_field:hbb.Message.cursor_id)
        CursorId(u64),
        // @@protoc_insertion_point(oneof_field:hbb.Message.key_event)
        KeyEvent(super::KeyEvent),
        // @@protoc_insertion_point(oneof_field:hbb.Message.clipboard)
        Clipboard(super::Clipboard),
        // @@protoc_insertion_point(oneof_field:hbb.Message.file_action)
        FileAction(super::FileAction),
        // @@protoc_insertion_point(oneof_field:hbb.Message.file_response)
        FileResponse(super::FileResponse),
        // @@protoc_insertion_point(oneof_field:hbb.Message.misc)
        Misc(super::Misc),
        // @@protoc_insertion_point(oneof_field:hbb.Message.cliprdr)
        Cliprdr(super::Cliprdr),
        // @@protoc_insertion_point(oneof_field:hbb.Message.message_box)
        MessageBox(super::MessageBox),
    }

    impl ::protobuf::Oneof for Union {
    }

    impl ::protobuf::OneofFull for Union {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Message as ::protobuf::MessageFull>::descriptor().oneof_by_name("union").unwrap()).clone()
        }
    }

    impl Union {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Union>("union")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.KeyboardMode)
pub enum KeyboardMode {
    // @@protoc_insertion_point(enum_value:hbb.KeyboardMode.Legacy)
    Legacy = 0,
    // @@protoc_insertion_point(enum_value:hbb.KeyboardMode.Map)
    Map = 1,
    // @@protoc_insertion_point(enum_value:hbb.KeyboardMode.Translate)
    Translate = 2,
    // @@protoc_insertion_point(enum_value:hbb.KeyboardMode.Auto)
    Auto = 3,
}

impl ::protobuf::Enum for KeyboardMode {
    const NAME: &'static str = "KeyboardMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeyboardMode> {
        match value {
            0 => ::std::option::Option::Some(KeyboardMode::Legacy),
            1 => ::std::option::Option::Some(KeyboardMode::Map),
            2 => ::std::option::Option::Some(KeyboardMode::Translate),
            3 => ::std::option::Option::Some(KeyboardMode::Auto),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KeyboardMode] = &[
        KeyboardMode::Legacy,
        KeyboardMode::Map,
        KeyboardMode::Translate,
        KeyboardMode::Auto,
    ];
}

impl ::protobuf::EnumFull for KeyboardMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KeyboardMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for KeyboardMode {
    fn default() -> Self {
        KeyboardMode::Legacy
    }
}

impl KeyboardMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KeyboardMode>("KeyboardMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.ControlKey)
pub enum ControlKey {
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Unknown)
    Unknown = 0,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Alt)
    Alt = 1,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Backspace)
    Backspace = 2,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.CapsLock)
    CapsLock = 3,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Control)
    Control = 4,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Delete)
    Delete = 5,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.DownArrow)
    DownArrow = 6,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.End)
    End = 7,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Escape)
    Escape = 8,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F1)
    F1 = 9,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F10)
    F10 = 10,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F11)
    F11 = 11,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F12)
    F12 = 12,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F2)
    F2 = 13,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F3)
    F3 = 14,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F4)
    F4 = 15,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F5)
    F5 = 16,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F6)
    F6 = 17,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F7)
    F7 = 18,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F8)
    F8 = 19,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.F9)
    F9 = 20,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Home)
    Home = 21,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.LeftArrow)
    LeftArrow = 22,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Meta)
    Meta = 23,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Option)
    Option = 24,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.PageDown)
    PageDown = 25,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.PageUp)
    PageUp = 26,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Return)
    Return = 27,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RightArrow)
    RightArrow = 28,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Shift)
    Shift = 29,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Space)
    Space = 30,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Tab)
    Tab = 31,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.UpArrow)
    UpArrow = 32,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad0)
    Numpad0 = 33,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad1)
    Numpad1 = 34,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad2)
    Numpad2 = 35,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad3)
    Numpad3 = 36,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad4)
    Numpad4 = 37,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad5)
    Numpad5 = 38,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad6)
    Numpad6 = 39,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad7)
    Numpad7 = 40,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad8)
    Numpad8 = 41,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Numpad9)
    Numpad9 = 42,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Cancel)
    Cancel = 43,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Clear)
    Clear = 44,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Menu)
    Menu = 45,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Pause)
    Pause = 46,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Kana)
    Kana = 47,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Hangul)
    Hangul = 48,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Junja)
    Junja = 49,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Final)
    Final = 50,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Hanja)
    Hanja = 51,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Kanji)
    Kanji = 52,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Convert)
    Convert = 53,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Select)
    Select = 54,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Print)
    Print = 55,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Execute)
    Execute = 56,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Snapshot)
    Snapshot = 57,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Insert)
    Insert = 58,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Help)
    Help = 59,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Sleep)
    Sleep = 60,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Separator)
    Separator = 61,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Scroll)
    Scroll = 62,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.NumLock)
    NumLock = 63,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RWin)
    RWin = 64,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Apps)
    Apps = 65,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Multiply)
    Multiply = 66,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Add)
    Add = 67,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Subtract)
    Subtract = 68,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Decimal)
    Decimal = 69,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Divide)
    Divide = 70,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.Equals)
    Equals = 71,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.NumpadEnter)
    NumpadEnter = 72,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RShift)
    RShift = 73,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RControl)
    RControl = 74,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.RAlt)
    RAlt = 75,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.CtrlAltDel)
    CtrlAltDel = 100,
    // @@protoc_insertion_point(enum_value:hbb.ControlKey.LockScreen)
    LockScreen = 101,
}

impl ::protobuf::Enum for ControlKey {
    const NAME: &'static str = "ControlKey";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ControlKey> {
        match value {
            0 => ::std::option::Option::Some(ControlKey::Unknown),
            1 => ::std::option::Option::Some(ControlKey::Alt),
            2 => ::std::option::Option::Some(ControlKey::Backspace),
            3 => ::std::option::Option::Some(ControlKey::CapsLock),
            4 => ::std::option::Option::Some(ControlKey::Control),
            5 => ::std::option::Option::Some(ControlKey::Delete),
            6 => ::std::option::Option::Some(ControlKey::DownArrow),
            7 => ::std::option::Option::Some(ControlKey::End),
            8 => ::std::option::Option::Some(ControlKey::Escape),
            9 => ::std::option::Option::Some(ControlKey::F1),
            10 => ::std::option::Option::Some(ControlKey::F10),
            11 => ::std::option::Option::Some(ControlKey::F11),
            12 => ::std::option::Option::Some(ControlKey::F12),
            13 => ::std::option::Option::Some(ControlKey::F2),
            14 => ::std::option::Option::Some(ControlKey::F3),
            15 => ::std::option::Option::Some(ControlKey::F4),
            16 => ::std::option::Option::Some(ControlKey::F5),
            17 => ::std::option::Option::Some(ControlKey::F6),
            18 => ::std::option::Option::Some(ControlKey::F7),
            19 => ::std::option::Option::Some(ControlKey::F8),
            20 => ::std::option::Option::Some(ControlKey::F9),
            21 => ::std::option::Option::Some(ControlKey::Home),
            22 => ::std::option::Option::Some(ControlKey::LeftArrow),
            23 => ::std::option::Option::Some(ControlKey::Meta),
            24 => ::std::option::Option::Some(ControlKey::Option),
            25 => ::std::option::Option::Some(ControlKey::PageDown),
            26 => ::std::option::Option::Some(ControlKey::PageUp),
            27 => ::std::option::Option::Some(ControlKey::Return),
            28 => ::std::option::Option::Some(ControlKey::RightArrow),
            29 => ::std::option::Option::Some(ControlKey::Shift),
            30 => ::std::option::Option::Some(ControlKey::Space),
            31 => ::std::option::Option::Some(ControlKey::Tab),
            32 => ::std::option::Option::Some(ControlKey::UpArrow),
            33 => ::std::option::Option::Some(ControlKey::Numpad0),
            34 => ::std::option::Option::Some(ControlKey::Numpad1),
            35 => ::std::option::Option::Some(ControlKey::Numpad2),
            36 => ::std::option::Option::Some(ControlKey::Numpad3),
            37 => ::std::option::Option::Some(ControlKey::Numpad4),
            38 => ::std::option::Option::Some(ControlKey::Numpad5),
            39 => ::std::option::Option::Some(ControlKey::Numpad6),
            40 => ::std::option::Option::Some(ControlKey::Numpad7),
            41 => ::std::option::Option::Some(ControlKey::Numpad8),
            42 => ::std::option::Option::Some(ControlKey::Numpad9),
            43 => ::std::option::Option::Some(ControlKey::Cancel),
            44 => ::std::option::Option::Some(ControlKey::Clear),
            45 => ::std::option::Option::Some(ControlKey::Menu),
            46 => ::std::option::Option::Some(ControlKey::Pause),
            47 => ::std::option::Option::Some(ControlKey::Kana),
            48 => ::std::option::Option::Some(ControlKey::Hangul),
            49 => ::std::option::Option::Some(ControlKey::Junja),
            50 => ::std::option::Option::Some(ControlKey::Final),
            51 => ::std::option::Option::Some(ControlKey::Hanja),
            52 => ::std::option::Option::Some(ControlKey::Kanji),
            53 => ::std::option::Option::Some(ControlKey::Convert),
            54 => ::std::option::Option::Some(ControlKey::Select),
            55 => ::std::option::Option::Some(ControlKey::Print),
            56 => ::std::option::Option::Some(ControlKey::Execute),
            57 => ::std::option::Option::Some(ControlKey::Snapshot),
            58 => ::std::option::Option::Some(ControlKey::Insert),
            59 => ::std::option::Option::Some(ControlKey::Help),
            60 => ::std::option::Option::Some(ControlKey::Sleep),
            61 => ::std::option::Option::Some(ControlKey::Separator),
            62 => ::std::option::Option::Some(ControlKey::Scroll),
            63 => ::std::option::Option::Some(ControlKey::NumLock),
            64 => ::std::option::Option::Some(ControlKey::RWin),
            65 => ::std::option::Option::Some(ControlKey::Apps),
            66 => ::std::option::Option::Some(ControlKey::Multiply),
            67 => ::std::option::Option::Some(ControlKey::Add),
            68 => ::std::option::Option::Some(ControlKey::Subtract),
            69 => ::std::option::Option::Some(ControlKey::Decimal),
            70 => ::std::option::Option::Some(ControlKey::Divide),
            71 => ::std::option::Option::Some(ControlKey::Equals),
            72 => ::std::option::Option::Some(ControlKey::NumpadEnter),
            73 => ::std::option::Option::Some(ControlKey::RShift),
            74 => ::std::option::Option::Some(ControlKey::RControl),
            75 => ::std::option::Option::Some(ControlKey::RAlt),
            100 => ::std::option::Option::Some(ControlKey::CtrlAltDel),
            101 => ::std::option::Option::Some(ControlKey::LockScreen),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ControlKey] = &[
        ControlKey::Unknown,
        ControlKey::Alt,
        ControlKey::Backspace,
        ControlKey::CapsLock,
        ControlKey::Control,
        ControlKey::Delete,
        ControlKey::DownArrow,
        ControlKey::End,
        ControlKey::Escape,
        ControlKey::F1,
        ControlKey::F10,
        ControlKey::F11,
        ControlKey::F12,
        ControlKey::F2,
        ControlKey::F3,
        ControlKey::F4,
        ControlKey::F5,
        ControlKey::F6,
        ControlKey::F7,
        ControlKey::F8,
        ControlKey::F9,
        ControlKey::Home,
        ControlKey::LeftArrow,
        ControlKey::Meta,
        ControlKey::Option,
        ControlKey::PageDown,
        ControlKey::PageUp,
        ControlKey::Return,
        ControlKey::RightArrow,
        ControlKey::Shift,
        ControlKey::Space,
        ControlKey::Tab,
        ControlKey::UpArrow,
        ControlKey::Numpad0,
        ControlKey::Numpad1,
        ControlKey::Numpad2,
        ControlKey::Numpad3,
        ControlKey::Numpad4,
        ControlKey::Numpad5,
        ControlKey::Numpad6,
        ControlKey::Numpad7,
        ControlKey::Numpad8,
        ControlKey::Numpad9,
        ControlKey::Cancel,
        ControlKey::Clear,
        ControlKey::Menu,
        ControlKey::Pause,
        ControlKey::Kana,
        ControlKey::Hangul,
        ControlKey::Junja,
        ControlKey::Final,
        ControlKey::Hanja,
        ControlKey::Kanji,
        ControlKey::Convert,
        ControlKey::Select,
        ControlKey::Print,
        ControlKey::Execute,
        ControlKey::Snapshot,
        ControlKey::Insert,
        ControlKey::Help,
        ControlKey::Sleep,
        ControlKey::Separator,
        ControlKey::Scroll,
        ControlKey::NumLock,
        ControlKey::RWin,
        ControlKey::Apps,
        ControlKey::Multiply,
        ControlKey::Add,
        ControlKey::Subtract,
        ControlKey::Decimal,
        ControlKey::Divide,
        ControlKey::Equals,
        ControlKey::NumpadEnter,
        ControlKey::RShift,
        ControlKey::RControl,
        ControlKey::RAlt,
        ControlKey::CtrlAltDel,
        ControlKey::LockScreen,
    ];
}

impl ::protobuf::EnumFull for ControlKey {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ControlKey").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ControlKey::Unknown => 0,
            ControlKey::Alt => 1,
            ControlKey::Backspace => 2,
            ControlKey::CapsLock => 3,
            ControlKey::Control => 4,
            ControlKey::Delete => 5,
            ControlKey::DownArrow => 6,
            ControlKey::End => 7,
            ControlKey::Escape => 8,
            ControlKey::F1 => 9,
            ControlKey::F10 => 10,
            ControlKey::F11 => 11,
            ControlKey::F12 => 12,
            ControlKey::F2 => 13,
            ControlKey::F3 => 14,
            ControlKey::F4 => 15,
            ControlKey::F5 => 16,
            ControlKey::F6 => 17,
            ControlKey::F7 => 18,
            ControlKey::F8 => 19,
            ControlKey::F9 => 20,
            ControlKey::Home => 21,
            ControlKey::LeftArrow => 22,
            ControlKey::Meta => 23,
            ControlKey::Option => 24,
            ControlKey::PageDown => 25,
            ControlKey::PageUp => 26,
            ControlKey::Return => 27,
            ControlKey::RightArrow => 28,
            ControlKey::Shift => 29,
            ControlKey::Space => 30,
            ControlKey::Tab => 31,
            ControlKey::UpArrow => 32,
            ControlKey::Numpad0 => 33,
            ControlKey::Numpad1 => 34,
            ControlKey::Numpad2 => 35,
            ControlKey::Numpad3 => 36,
            ControlKey::Numpad4 => 37,
            ControlKey::Numpad5 => 38,
            ControlKey::Numpad6 => 39,
            ControlKey::Numpad7 => 40,
            ControlKey::Numpad8 => 41,
            ControlKey::Numpad9 => 42,
            ControlKey::Cancel => 43,
            ControlKey::Clear => 44,
            ControlKey::Menu => 45,
            ControlKey::Pause => 46,
            ControlKey::Kana => 47,
            ControlKey::Hangul => 48,
            ControlKey::Junja => 49,
            ControlKey::Final => 50,
            ControlKey::Hanja => 51,
            ControlKey::Kanji => 52,
            ControlKey::Convert => 53,
            ControlKey::Select => 54,
            ControlKey::Print => 55,
            ControlKey::Execute => 56,
            ControlKey::Snapshot => 57,
            ControlKey::Insert => 58,
            ControlKey::Help => 59,
            ControlKey::Sleep => 60,
            ControlKey::Separator => 61,
            ControlKey::Scroll => 62,
            ControlKey::NumLock => 63,
            ControlKey::RWin => 64,
            ControlKey::Apps => 65,
            ControlKey::Multiply => 66,
            ControlKey::Add => 67,
            ControlKey::Subtract => 68,
            ControlKey::Decimal => 69,
            ControlKey::Divide => 70,
            ControlKey::Equals => 71,
            ControlKey::NumpadEnter => 72,
            ControlKey::RShift => 73,
            ControlKey::RControl => 74,
            ControlKey::RAlt => 75,
            ControlKey::CtrlAltDel => 76,
            ControlKey::LockScreen => 77,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ControlKey {
    fn default() -> Self {
        ControlKey::Unknown
    }
}

impl ControlKey {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ControlKey>("ControlKey")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.FileType)
pub enum FileType {
    // @@protoc_insertion_point(enum_value:hbb.FileType.Dir)
    Dir = 0,
    // @@protoc_insertion_point(enum_value:hbb.FileType.DirLink)
    DirLink = 2,
    // @@protoc_insertion_point(enum_value:hbb.FileType.DirDrive)
    DirDrive = 3,
    // @@protoc_insertion_point(enum_value:hbb.FileType.File)
    File = 4,
    // @@protoc_insertion_point(enum_value:hbb.FileType.FileLink)
    FileLink = 5,
}

impl ::protobuf::Enum for FileType {
    const NAME: &'static str = "FileType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileType> {
        match value {
            0 => ::std::option::Option::Some(FileType::Dir),
            2 => ::std::option::Option::Some(FileType::DirLink),
            3 => ::std::option::Option::Some(FileType::DirDrive),
            4 => ::std::option::Option::Some(FileType::File),
            5 => ::std::option::Option::Some(FileType::FileLink),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FileType] = &[
        FileType::Dir,
        FileType::DirLink,
        FileType::DirDrive,
        FileType::File,
        FileType::FileLink,
    ];
}

impl ::protobuf::EnumFull for FileType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FileType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            FileType::Dir => 0,
            FileType::DirLink => 1,
            FileType::DirDrive => 2,
            FileType::File => 3,
            FileType::FileLink => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FileType {
    fn default() -> Self {
        FileType::Dir
    }
}

impl FileType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FileType>("FileType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:hbb.ImageQuality)
pub enum ImageQuality {
    // @@protoc_insertion_point(enum_value:hbb.ImageQuality.NotSet)
    NotSet = 0,
    // @@protoc_insertion_point(enum_value:hbb.ImageQuality.Low)
    Low = 2,
    // @@protoc_insertion_point(enum_value:hbb.ImageQuality.Balanced)
    Balanced = 3,
    // @@protoc_insertion_point(enum_value:hbb.ImageQuality.Best)
    Best = 4,
}

impl ::protobuf::Enum for ImageQuality {
    const NAME: &'static str = "ImageQuality";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImageQuality> {
        match value {
            0 => ::std::option::Option::Some(ImageQuality::NotSet),
            2 => ::std::option::Option::Some(ImageQuality::Low),
            3 => ::std::option::Option::Some(ImageQuality::Balanced),
            4 => ::std::option::Option::Some(ImageQuality::Best),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ImageQuality] = &[
        ImageQuality::NotSet,
        ImageQuality::Low,
        ImageQuality::Balanced,
        ImageQuality::Best,
    ];
}

impl ::protobuf::EnumFull for ImageQuality {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ImageQuality").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ImageQuality::NotSet => 0,
            ImageQuality::Low => 1,
            ImageQuality::Balanced => 2,
            ImageQuality::Best => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ImageQuality {
    fn default() -> Self {
        ImageQuality::NotSet
    }
}

impl ImageQuality {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ImageQuality>("ImageQuality")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\x12\x03hbb\"K\n\x11EncodedVideoFrame\x12\x12\n\x04data\
    \x18\x01\x20\x01(\x0cR\x04data\x12\x10\n\x03key\x18\x02\x20\x01(\x08R\
    \x03key\x12\x10\n\x03pts\x18\x03\x20\x01(\x03R\x03pts\"D\n\x12EncodedVid\
    eoFrames\x12.\n\x06frames\x18\x01\x20\x03(\x0b2\x16.hbb.EncodedVideoFram\
    eR\x06frames\"!\n\x03RGB\x12\x1a\n\x08compress\x18\x01\x20\x01(\x08R\x08\
    compress\"9\n\x03YUV\x12\x1a\n\x08compress\x18\x01\x20\x01(\x08R\x08comp\
    ress\x12\x16\n\x06stride\x18\x02\x20\x01(\x05R\x06stride\"\x80\x02\n\nVi\
    deoFrame\x12-\n\x04vp9s\x18\x06\x20\x01(\x0b2\x17.hbb.EncodedVideoFrames\
    H\0R\x04vp9s\x12\x1c\n\x03rgb\x18\x07\x20\x01(\x0b2\x08.hbb.RGBH\0R\x03r\
    gb\x12\x1c\n\x03yuv\x18\x08\x20\x01(\x0b2\x08.hbb.YUVH\0R\x03yuv\x12/\n\
    \x05h264s\x18\n\x20\x01(\x0b2\x17.hbb.EncodedVideoFramesH\0R\x05h264s\
    \x12/\n\x05h265s\x18\x0b\x20\x01(\x0b2\x17.hbb.EncodedVideoFramesH\0R\
    \x05h265s\x12\x1c\n\ttimestamp\x18\t\x20\x01(\x03R\ttimestampB\x07\n\x05\
    union\"&\n\x04IdPk\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x0e\n\
    \x02pk\x18\x02\x20\x01(\x0cR\x02pk\"\xac\x01\n\x0bDisplayInfo\x12\x0c\n\
    \x01x\x18\x01\x20\x01(\x11R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x11R\
    \x01y\x12\x14\n\x05width\x18\x03\x20\x01(\x05R\x05width\x12\x16\n\x06hei\
    ght\x18\x04\x20\x01(\x05R\x06height\x12\x12\n\x04name\x18\x05\x20\x01(\t\
    R\x04name\x12\x16\n\x06online\x18\x06\x20\x01(\x08R\x06online\x12'\n\x0f\
    cursor_embedded\x18\x07\x20\x01(\x08R\x0ecursorEmbedded\"5\n\x0bPortForw\
    ard\x12\x12\n\x04host\x18\x01\x20\x01(\tR\x04host\x12\x12\n\x04port\x18\
    \x02\x20\x01(\x05R\x04port\"A\n\x0cFileTransfer\x12\x10\n\x03dir\x18\x01\
    \x20\x01(\tR\x03dir\x12\x1f\n\x0bshow_hidden\x18\x02\x20\x01(\x08R\nshow\
    Hidden\"\x81\x03\n\x0cLoginRequest\x12\x1a\n\x08username\x18\x01\x20\x01\
    (\tR\x08username\x12\x1a\n\x08password\x18\x02\x20\x01(\x0cR\x08password\
    \x12\x13\n\x05my_id\x18\x04\x20\x01(\tR\x04myId\x12\x17\n\x07my_name\x18\
    \x05\x20\x01(\tR\x06myName\x12*\n\x06option\x18\x06\x20\x01(\x0b2\x12.hb\
    b.OptionMessageR\x06option\x128\n\rfile_transfer\x18\x07\x20\x01(\x0b2\
    \x11.hbb.FileTransferH\0R\x0cfileTransfer\x125\n\x0cport_forward\x18\x08\
    \x20\x01(\x0b2\x10.hbb.PortForwardH\0R\x0bportForward\x12,\n\x12video_ac\
    k_required\x18\t\x20\x01(\x08R\x10videoAckRequired\x12\x1d\n\nsession_id\
    \x18\n\x20\x01(\x04R\tsessionId\x12\x18\n\x07version\x18\x0b\x20\x01(\tR\
    \x07versionB\x07\n\x05union\"!\n\x0bChatMessage\x12\x12\n\x04text\x18\
    \x01\x20\x01(\tR\x04text\"-\n\x08Features\x12!\n\x0cprivacy_mode\x18\x01\
    \x20\x01(\x08R\x0bprivacyMode\";\n\x11SupportedEncoding\x12\x12\n\x04h26\
    4\x18\x01\x20\x01(\x08R\x04h264\x12\x12\n\x04h265\x18\x02\x20\x01(\x08R\
    \x04h265\"\xe8\x02\n\x08PeerInfo\x12\x1a\n\x08username\x18\x01\x20\x01(\
    \tR\x08username\x12\x1a\n\x08hostname\x18\x02\x20\x01(\tR\x08hostname\
    \x12\x1a\n\x08platform\x18\x03\x20\x01(\tR\x08platform\x12,\n\x08display\
    s\x18\x04\x20\x03(\x0b2\x10.hbb.DisplayInfoR\x08displays\x12'\n\x0fcurre\
    nt_display\x18\x05\x20\x01(\x05R\x0ecurrentDisplay\x12\x1f\n\x0bsas_enab\
    led\x18\x06\x20\x01(\x08R\nsasEnabled\x12\x18\n\x07version\x18\x07\x20\
    \x01(\tR\x07version\x12\x17\n\x07conn_id\x18\x08\x20\x01(\x05R\x06connId\
    \x12)\n\x08features\x18\t\x20\x01(\x0b2\r.hbb.FeaturesR\x08features\x122\
    \n\x08encoding\x18\n\x20\x01(\x0b2\x16.hbb.SupportedEncodingR\x08encodin\
    g\"^\n\rLoginResponse\x12\x16\n\x05error\x18\x01\x20\x01(\tH\0R\x05error\
    \x12,\n\tpeer_info\x18\x02\x20\x01(\x0b2\r.hbb.PeerInfoH\0R\x08peerInfoB\
    \x07\n\x05union\"k\n\nMouseEvent\x12\x12\n\x04mask\x18\x01\x20\x01(\x05R\
    \x04mask\x12\x0c\n\x01x\x18\x02\x20\x01(\x11R\x01x\x12\x0c\n\x01y\x18\
    \x03\x20\x01(\x11R\x01y\x12-\n\tmodifiers\x18\x04\x20\x03(\x0e2\x0f.hbb.\
    ControlKeyR\tmodifiers\"\x8b\x02\n\x08KeyEvent\x12\x12\n\x04down\x18\x01\
    \x20\x01(\x08R\x04down\x12\x14\n\x05press\x18\x02\x20\x01(\x08R\x05press\
    \x122\n\x0bcontrol_key\x18\x03\x20\x01(\x0e2\x0f.hbb.ControlKeyH\0R\ncon\
    trolKey\x12\x12\n\x03chr\x18\x04\x20\x01(\rH\0R\x03chr\x12\x1a\n\x07unic\
    ode\x18\x05\x20\x01(\rH\0R\x07unicode\x12\x12\n\x03seq\x18\x06\x20\x01(\
    \tH\0R\x03seq\x12-\n\tmodifiers\x18\x08\x20\x03(\x0e2\x0f.hbb.ControlKey\
    R\tmodifiers\x12%\n\x04mode\x18\t\x20\x01(\x0e2\x11.hbb.KeyboardModeR\
    \x04modeB\x07\n\x05union\"\x8a\x01\n\nCursorData\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x04R\x02id\x12\x12\n\x04hotx\x18\x02\x20\x01(\x11R\x04hotx\x12\
    \x12\n\x04hoty\x18\x03\x20\x01(\x11R\x04hoty\x12\x14\n\x05width\x18\x04\
    \x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\x05R\x06hei\
    ght\x12\x16\n\x06colors\x18\x06\x20\x01(\x0cR\x06colors\",\n\x0eCursorPo\
    sition\x12\x0c\n\x01x\x18\x01\x20\x01(\x11R\x01x\x12\x0c\n\x01y\x18\x02\
    \x20\x01(\x11R\x01y\"8\n\x04Hash\x12\x12\n\x04salt\x18\x01\x20\x01(\tR\
    \x04salt\x12\x1c\n\tchallenge\x18\x02\x20\x01(\tR\tchallenge\"A\n\tClipb\
    oard\x12\x1a\n\x08compress\x18\x01\x20\x01(\x08R\x08compress\x12\x18\n\
    \x07content\x18\x02\x20\x01(\x0cR\x07content\"\xa3\x01\n\tFileEntry\x12,\
    \n\nentry_type\x18\x01\x20\x01(\x0e2\r.hbb.FileTypeR\tentryType\x12\x12\
    \n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1b\n\tis_hidden\x18\x03\x20\
    \x01(\x08R\x08isHidden\x12\x12\n\x04size\x18\x04\x20\x01(\x04R\x04size\
    \x12#\n\rmodified_time\x18\x05\x20\x01(\x04R\x0cmodifiedTime\"]\n\rFileD\
    irectory\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04path\
    \x18\x02\x20\x01(\tR\x04path\x12(\n\x07entries\x18\x03\x20\x03(\x0b2\x0e\
    .hbb.FileEntryR\x07entries\"D\n\x07ReadDir\x12\x12\n\x04path\x18\x01\x20\
    \x01(\tR\x04path\x12%\n\x0einclude_hidden\x18\x02\x20\x01(\x08R\rinclude\
    Hidden\"Y\n\x0cReadAllFiles\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\
    \x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12%\n\x0einclude_hidden\
    \x18\x03\x20\x01(\x08R\rincludeHidden\"\xfb\x03\n\nFileAction\x12)\n\x08\
    read_dir\x18\x01\x20\x01(\x0b2\x0c.hbb.ReadDirH\0R\x07readDir\x122\n\x04\
    send\x18\x02\x20\x01(\x0b2\x1c.hbb.FileTransferSendRequestH\0R\x04send\
    \x12;\n\x07receive\x18\x03\x20\x01(\x0b2\x1f.hbb.FileTransferReceiveRequ\
    estH\0R\x07receive\x12,\n\x06create\x18\x04\x20\x01(\x0b2\x12.hbb.FileDi\
    rCreateH\0R\x06create\x123\n\nremove_dir\x18\x05\x20\x01(\x0b2\x12.hbb.F\
    ileRemoveDirH\0R\tremoveDir\x126\n\x0bremove_file\x18\x06\x20\x01(\x0b2\
    \x13.hbb.FileRemoveFileH\0R\nremoveFile\x120\n\tall_files\x18\x07\x20\
    \x01(\x0b2\x11.hbb.ReadAllFilesH\0R\x08allFiles\x121\n\x06cancel\x18\x08\
    \x20\x01(\x0b2\x17.hbb.FileTransferCancelH\0R\x06cancel\x12H\n\x0csend_c\
    onfirm\x18\t\x20\x01(\x0b2#.hbb.FileTransferSendConfirmRequestH\0R\x0bse\
    ndConfirmB\x07\n\x05union\"$\n\x12FileTransferCancel\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\x05R\x02id\"\xff\x01\n\x0cFileResponse\x12&\n\x03dir\x18\
    \x01\x20\x01(\x0b2\x12.hbb.FileDirectoryH\0R\x03dir\x12.\n\x05block\x18\
    \x02\x20\x01(\x0b2\x16.hbb.FileTransferBlockH\0R\x05block\x12.\n\x05erro\
    r\x18\x03\x20\x01(\x0b2\x16.hbb.FileTransferErrorH\0R\x05error\x12+\n\
    \x04done\x18\x04\x20\x01(\x0b2\x15.hbb.FileTransferDoneH\0R\x04done\x121\
    \n\x06digest\x18\x05\x20\x01(\x0b2\x17.hbb.FileTransferDigestH\0R\x06dig\
    estB\x07\n\x05union\"\x9e\x01\n\x12FileTransferDigest\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x05R\x02id\x12\x19\n\x08file_num\x18\x02\x20\x01(\x11R\
    \x07fileNum\x12#\n\rlast_modified\x18\x03\x20\x01(\x04R\x0clastModified\
    \x12\x1b\n\tfile_size\x18\x04\x20\x01(\x04R\x08fileSize\x12\x1b\n\tis_up\
    load\x18\x05\x20\x01(\x08R\x08isUpload\"\x89\x01\n\x11FileTransferBlock\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x19\n\x08file_num\x18\
    \x02\x20\x01(\x11R\x07fileNum\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\
    \x04data\x12\x1e\n\ncompressed\x18\x04\x20\x01(\x08R\ncompressed\x12\x15\
    \n\x06blk_id\x18\x05\x20\x01(\rR\x05blkId\"T\n\x11FileTransferError\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x14\n\x05error\x18\x02\x20\
    \x01(\tR\x05error\x12\x19\n\x08file_num\x18\x03\x20\x01(\x11R\x07fileNum\
    \"\x7f\n\x17FileTransferSendRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\x05\
    R\x02id\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12%\n\x0einclude_\
    hidden\x18\x03\x20\x01(\x08R\rincludeHidden\x12\x19\n\x08file_num\x18\
    \x04\x20\x01(\x05R\x07fileNum\"\x8b\x01\n\x1eFileTransferSendConfirmRequ\
    est\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x19\n\x08file_num\
    \x18\x02\x20\x01(\x11R\x07fileNum\x12\x14\n\x04skip\x18\x03\x20\x01(\x08\
    H\0R\x04skip\x12\x1f\n\noffset_blk\x18\x04\x20\x01(\rH\0R\toffsetBlkB\
    \x07\n\x05union\"=\n\x10FileTransferDone\x12\x0e\n\x02id\x18\x01\x20\x01\
    (\x05R\x02id\x12\x19\n\x08file_num\x18\x02\x20\x01(\x11R\x07fileNum\"\
    \x81\x01\n\x1aFileTransferReceiveRequest\x12\x0e\n\x02id\x18\x01\x20\x01\
    (\x05R\x02id\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12$\n\x05fil\
    es\x18\x03\x20\x03(\x0b2\x0e.hbb.FileEntryR\x05files\x12\x19\n\x08file_n\
    um\x18\x04\x20\x01(\x05R\x07fileNum\"Q\n\rFileRemoveDir\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04pa\
    th\x12\x1c\n\trecursive\x18\x03\x20\x01(\x08R\trecursive\"O\n\x0eFileRem\
    oveFile\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04path\
    \x18\x02\x20\x01(\tR\x04path\x12\x19\n\x08file_num\x18\x03\x20\x01(\x11R\
    \x07fileNum\"3\n\rFileDirCreate\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\
    \x02id\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\"\x15\n\x13CliprdrM\
    onitorReady\"7\n\rCliprdrFormat\x12\x0e\n\x02id\x18\x02\x20\x01(\x05R\
    \x02id\x12\x16\n\x06format\x18\x03\x20\x01(\tR\x06format\"G\n\x17Cliprdr\
    ServerFormatList\x12,\n\x07formats\x18\x02\x20\x03(\x0b2\x12.hbb.Cliprdr\
    FormatR\x07formats\">\n\x1fCliprdrServerFormatListResponse\x12\x1b\n\tms\
    g_flags\x18\x02\x20\x01(\x05R\x08msgFlags\"P\n\x1eCliprdrServerFormatDat\
    aRequest\x12.\n\x13requested_format_id\x18\x02\x20\x01(\x05R\x11requeste\
    dFormatId\"_\n\x1fCliprdrServerFormatDataResponse\x12\x1b\n\tmsg_flags\
    \x18\x02\x20\x01(\x05R\x08msgFlags\x12\x1f\n\x0bformat_data\x18\x03\x20\
    \x01(\x0cR\nformatData\"\xb1\x02\n\x1aCliprdrFileContentsRequest\x12\x1b\
    \n\tstream_id\x18\x02\x20\x01(\x05R\x08streamId\x12\x1d\n\nlist_index\
    \x18\x03\x20\x01(\x05R\tlistIndex\x12\x19\n\x08dw_flags\x18\x04\x20\x01(\
    \x05R\x07dwFlags\x12$\n\x0en_position_low\x18\x05\x20\x01(\x05R\x0cnPosi\
    tionLow\x12&\n\x0fn_position_high\x18\x06\x20\x01(\x05R\rnPositionHigh\
    \x12!\n\x0ccb_requested\x18\x07\x20\x01(\x05R\x0bcbRequested\x12)\n\x11h\
    ave_clip_data_id\x18\x08\x20\x01(\x08R\x0ehaveClipDataId\x12\x20\n\x0ccl\
    ip_data_id\x18\t\x20\x01(\x05R\nclipDataId\"~\n\x1bCliprdrFileContentsRe\
    sponse\x12\x1b\n\tmsg_flags\x18\x03\x20\x01(\x05R\x08msgFlags\x12\x1b\n\
    \tstream_id\x18\x04\x20\x01(\x05R\x08streamId\x12%\n\x0erequested_data\
    \x18\x05\x20\x01(\x0cR\rrequestedData\"\xc1\x04\n\x07Cliprdr\x120\n\x05r\
    eady\x18\x01\x20\x01(\x0b2\x18.hbb.CliprdrMonitorReadyH\0R\x05ready\x12?\
    \n\x0bformat_list\x18\x02\x20\x01(\x0b2\x1c.hbb.CliprdrServerFormatListH\
    \0R\nformatList\x12X\n\x14format_list_response\x18\x03\x20\x01(\x0b2$.hb\
    b.CliprdrServerFormatListResponseH\0R\x12formatListResponse\x12U\n\x13fo\
    rmat_data_request\x18\x04\x20\x01(\x0b2#.hbb.CliprdrServerFormatDataRequ\
    estH\0R\x11formatDataRequest\x12X\n\x14format_data_response\x18\x05\x20\
    \x01(\x0b2$.hbb.CliprdrServerFormatDataResponseH\0R\x12formatDataRespons\
    e\x12U\n\x15file_contents_request\x18\x06\x20\x01(\x0b2\x1f.hbb.CliprdrF\
    ileContentsRequestH\0R\x13fileContentsRequest\x12X\n\x16file_contents_re\
    sponse\x18\x07\x20\x01(\x0b2\x20.hbb.CliprdrFileContentsResponseH\0R\x14\
    fileContentsResponseB\x07\n\x05union\"\x9c\x01\n\rSwitchDisplay\x12\x18\
    \n\x07display\x18\x01\x20\x01(\x05R\x07display\x12\x0c\n\x01x\x18\x02\
    \x20\x01(\x11R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x11R\x01y\x12\x14\n\
    \x05width\x18\x04\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x05\x20\
    \x01(\x05R\x06height\x12'\n\x0fcursor_embedded\x18\x06\x20\x01(\x08R\x0e\
    cursorEmbedded\"\xc6\x01\n\x0ePermissionInfo\x12>\n\npermission\x18\x01\
    \x20\x01(\x0e2\x1e.hbb.PermissionInfo.PermissionR\npermission\x12\x18\n\
    \x07enabled\x18\x02\x20\x01(\x08R\x07enabled\"Z\n\nPermission\x12\x0c\n\
    \x08Keyboard\x10\0\x12\r\n\tClipboard\x10\x02\x12\t\n\x05Audio\x10\x03\
    \x12\x08\n\x04File\x10\x04\x12\x0b\n\x07Restart\x10\x05\x12\r\n\tRecordi\
    ng\x10\x06\"\xdc\x01\n\x0fVideoCodecState\x12\x1b\n\tscore_vpx\x18\x01\
    \x20\x01(\x05R\x08scoreVpx\x12\x1d\n\nscore_h264\x18\x02\x20\x01(\x05R\t\
    scoreH264\x12\x1d\n\nscore_h265\x18\x03\x20\x01(\x05R\tscoreH265\x128\n\
    \x06prefer\x18\x04\x20\x01(\x0e2\x20.hbb.VideoCodecState.PreferCodecR\
    \x06prefer\"4\n\x0bPreferCodec\x12\x08\n\x04Auto\x10\0\x12\x07\n\x03VPX\
    \x10\x01\x12\x08\n\x04H264\x10\x02\x12\x08\n\x04H265\x10\x03\"\x89\x06\n\
    \rOptionMessage\x126\n\rimage_quality\x18\x01\x20\x01(\x0e2\x11.hbb.Imag\
    eQualityR\x0cimageQuality\x12R\n\x16lock_after_session_end\x18\x02\x20\
    \x01(\x0e2\x1d.hbb.OptionMessage.BoolOptionR\x13lockAfterSessionEnd\x12K\
    \n\x12show_remote_cursor\x18\x03\x20\x01(\x0e2\x1d.hbb.OptionMessage.Boo\
    lOptionR\x10showRemoteCursor\x12@\n\x0cprivacy_mode\x18\x04\x20\x01(\x0e\
    2\x1d.hbb.OptionMessage.BoolOptionR\x0bprivacyMode\x12>\n\x0bblock_input\
    \x18\x05\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolOptionR\nblockInput\x12\
    0\n\x14custom_image_quality\x18\x06\x20\x01(\x05R\x12customImageQuality\
    \x12B\n\rdisable_audio\x18\x07\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolO\
    ptionR\x0cdisableAudio\x12J\n\x11disable_clipboard\x18\x08\x20\x01(\x0e2\
    \x1d.hbb.OptionMessage.BoolOptionR\x10disableClipboard\x12O\n\x14enable_\
    file_transfer\x18\t\x20\x01(\x0e2\x1d.hbb.OptionMessage.BoolOptionR\x12e\
    nableFileTransfer\x12@\n\x11video_codec_state\x18\n\x20\x01(\x0b2\x14.hb\
    b.VideoCodecStateR\x0fvideoCodecState\x12\x1d\n\ncustom_fps\x18\x0b\x20\
    \x01(\x05R\tcustomFps\")\n\nBoolOption\x12\n\n\x06NotSet\x10\0\x12\x06\n\
    \x02No\x10\x01\x12\x07\n\x03Yes\x10\x02\"\x86\x01\n\tTestDelay\x12\x12\n\
    \x04time\x18\x01\x20\x01(\x03R\x04time\x12\x1f\n\x0bfrom_client\x18\x02\
    \x20\x01(\x08R\nfromClient\x12\x1d\n\nlast_delay\x18\x03\x20\x01(\rR\tla\
    stDelay\x12%\n\x0etarget_bitrate\x18\x04\x20\x01(\rR\rtargetBitrate\"_\n\
    \tPublicKey\x12)\n\x10asymmetric_value\x18\x01\x20\x01(\x0cR\x0fasymmetr\
    icValue\x12'\n\x0fsymmetric_value\x18\x02\x20\x01(\x0cR\x0esymmetricValu\
    e\"\x1a\n\x08SignedId\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\"J\n\
    \x0bAudioFormat\x12\x1f\n\x0bsample_rate\x18\x01\x20\x01(\rR\nsampleRate\
    \x12\x1a\n\x08channels\x18\x02\x20\x01(\rR\x08channels\">\n\nAudioFrame\
    \x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x1c\n\ttimestamp\
    \x18\x02\x20\x01(\x03R\ttimestamp\"d\n\nMessageBox\x12\x18\n\x07msgtype\
    \x18\x01\x20\x01(\tR\x07msgtype\x12\x14\n\x05title\x18\x02\x20\x01(\tR\
    \x05title\x12\x12\n\x04text\x18\x03\x20\x01(\tR\x04text\x12\x12\n\x04lin\
    k\x18\x04\x20\x01(\tR\x04link\"\xac\x04\n\x10BackNotification\x12V\n\x12\
    privacy_mode_state\x18\x01\x20\x01(\x0e2&.hbb.BackNotification.PrivacyMo\
    deStateH\0R\x10privacyModeState\x12S\n\x11block_input_state\x18\x02\x20\
    \x01(\x0e2%.hbb.BackNotification.BlockInputStateH\0R\x0fblockInputState\
    \"r\n\x0fBlockInputState\x12\x13\n\x0fBlkStateUnknown\x10\0\x12\x12\n\
    \x0eBlkOnSucceeded\x10\x02\x12\x0f\n\x0bBlkOnFailed\x10\x03\x12\x13\n\
    \x0fBlkOffSucceeded\x10\x04\x12\x10\n\x0cBlkOffFailed\x10\x05\"\xed\x01\
    \n\x10PrivacyModeState\x12\x13\n\x0fPrvStateUnknown\x10\0\x12\x10\n\x0cP\
    rvOnByOther\x10\x02\x12\x13\n\x0fPrvNotSupported\x10\x03\x12\x12\n\x0ePr\
    vOnSucceeded\x10\x04\x12\x15\n\x11PrvOnFailedDenied\x10\x05\x12\x15\n\
    \x11PrvOnFailedPlugin\x10\x06\x12\x0f\n\x0bPrvOnFailed\x10\x07\x12\x13\n\
    \x0fPrvOffSucceeded\x10\x08\x12\x10\n\x0cPrvOffByPeer\x10\t\x12\x10\n\
    \x0cPrvOffFailed\x10\n\x12\x11\n\rPrvOffUnknown\x10\x0bB\x07\n\x05union\
    \"S\n\x19ElevationRequestWithLogon\x12\x1a\n\x08username\x18\x01\x20\x01\
    (\tR\x08username\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\"\
    m\n\x10ElevationRequest\x12\x18\n\x06direct\x18\x01\x20\x01(\x08H\0R\x06\
    direct\x126\n\x05logon\x18\x02\x20\x01(\x0b2\x1e.hbb.ElevationRequestWit\
    hLogonH\0R\x05logonB\x07\n\x05union\"\xc5\x06\n\x04Misc\x125\n\x0cchat_m\
    essage\x18\x04\x20\x01(\x0b2\x10.hbb.ChatMessageH\0R\x0bchatMessage\x12;\
    \n\x0eswitch_display\x18\x05\x20\x01(\x0b2\x12.hbb.SwitchDisplayH\0R\rsw\
    itchDisplay\x12>\n\x0fpermission_info\x18\x06\x20\x01(\x0b2\x13.hbb.Perm\
    issionInfoH\0R\x0epermissionInfo\x12,\n\x06option\x18\x07\x20\x01(\x0b2\
    \x12.hbb.OptionMessageH\0R\x06option\x125\n\x0caudio_format\x18\x08\x20\
    \x01(\x0b2\x10.hbb.AudioFormatH\0R\x0baudioFormat\x12#\n\x0cclose_reason\
    \x18\t\x20\x01(\tH\0R\x0bcloseReason\x12%\n\rrefresh_video\x18\n\x20\x01\
    (\x08H\0R\x0crefreshVideo\x12'\n\x0evideo_received\x18\x0c\x20\x01(\x08H\
    \0R\rvideoReceived\x12D\n\x11back_notification\x18\r\x20\x01(\x0b2\x15.h\
    bb.BackNotificationH\0R\x10backNotification\x124\n\x15restart_remote_dev\
    ice\x18\x0e\x20\x01(\x08H\0R\x13restartRemoteDevice\x12\x12\n\x03uac\x18\
    \x0f\x20\x01(\x08H\0R\x03uac\x12>\n\x1aforeground_window_elevated\x18\
    \x10\x20\x01(\x08H\0R\x18foregroundWindowElevated\x12#\n\x0cstop_service\
    \x18\x11\x20\x01(\x08H\0R\x0bstopService\x12D\n\x11elevation_request\x18\
    \x12\x20\x01(\x0b2\x15.hbb.ElevationRequestH\0R\x10elevationRequest\x12/\
    \n\x12elevation_response\x18\x13\x20\x01(\tH\0R\x11elevationResponse\x12\
    :\n\x18portable_service_running\x18\x14\x20\x01(\x08H\0R\x16portableServ\
    iceRunningB\x07\n\x05union\"\xb4\x07\n\x07Message\x12,\n\tsigned_id\x18\
    \x03\x20\x01(\x0b2\r.hbb.SignedIdH\0R\x08signedId\x12/\n\npublic_key\x18\
    \x04\x20\x01(\x0b2\x0e.hbb.PublicKeyH\0R\tpublicKey\x12/\n\ntest_delay\
    \x18\x05\x20\x01(\x0b2\x0e.hbb.TestDelayH\0R\ttestDelay\x122\n\x0bvideo_\
    frame\x18\x06\x20\x01(\x0b2\x0f.hbb.VideoFrameH\0R\nvideoFrame\x128\n\rl\
    ogin_request\x18\x07\x20\x01(\x0b2\x11.hbb.LoginRequestH\0R\x0cloginRequ\
    est\x12;\n\x0elogin_response\x18\x08\x20\x01(\x0b2\x12.hbb.LoginResponse\
    H\0R\rloginResponse\x12\x1f\n\x04hash\x18\t\x20\x01(\x0b2\t.hbb.HashH\0R\
    \x04hash\x122\n\x0bmouse_event\x18\n\x20\x01(\x0b2\x0f.hbb.MouseEventH\0\
    R\nmouseEvent\x122\n\x0baudio_frame\x18\x0b\x20\x01(\x0b2\x0f.hbb.AudioF\
    rameH\0R\naudioFrame\x122\n\x0bcursor_data\x18\x0c\x20\x01(\x0b2\x0f.hbb\
    .CursorDataH\0R\ncursorData\x12>\n\x0fcursor_position\x18\r\x20\x01(\x0b\
    2\x13.hbb.CursorPositionH\0R\x0ecursorPosition\x12\x1d\n\tcursor_id\x18\
    \x0e\x20\x01(\x04H\0R\x08cursorId\x12,\n\tkey_event\x18\x0f\x20\x01(\x0b\
    2\r.hbb.KeyEventH\0R\x08keyEvent\x12.\n\tclipboard\x18\x10\x20\x01(\x0b2\
    \x0e.hbb.ClipboardH\0R\tclipboard\x122\n\x0bfile_action\x18\x11\x20\x01(\
    \x0b2\x0f.hbb.FileActionH\0R\nfileAction\x128\n\rfile_response\x18\x12\
    \x20\x01(\x0b2\x11.hbb.FileResponseH\0R\x0cfileResponse\x12\x1f\n\x04mis\
    c\x18\x13\x20\x01(\x0b2\t.hbb.MiscH\0R\x04misc\x12(\n\x07cliprdr\x18\x14\
    \x20\x01(\x0b2\x0c.hbb.CliprdrH\0R\x07cliprdr\x122\n\x0bmessage_box\x18\
    \x15\x20\x01(\x0b2\x0f.hbb.MessageBoxH\0R\nmessageBoxB\x07\n\x05union*<\
    \n\x0cKeyboardMode\x12\n\n\x06Legacy\x10\0\x12\x07\n\x03Map\x10\x01\x12\
    \r\n\tTranslate\x10\x02\x12\x08\n\x04Auto\x10\x03*\x9b\x07\n\nControlKey\
    \x12\x0b\n\x07Unknown\x10\0\x12\x07\n\x03Alt\x10\x01\x12\r\n\tBackspace\
    \x10\x02\x12\x0c\n\x08CapsLock\x10\x03\x12\x0b\n\x07Control\x10\x04\x12\
    \n\n\x06Delete\x10\x05\x12\r\n\tDownArrow\x10\x06\x12\x07\n\x03End\x10\
    \x07\x12\n\n\x06Escape\x10\x08\x12\x06\n\x02F1\x10\t\x12\x07\n\x03F10\
    \x10\n\x12\x07\n\x03F11\x10\x0b\x12\x07\n\x03F12\x10\x0c\x12\x06\n\x02F2\
    \x10\r\x12\x06\n\x02F3\x10\x0e\x12\x06\n\x02F4\x10\x0f\x12\x06\n\x02F5\
    \x10\x10\x12\x06\n\x02F6\x10\x11\x12\x06\n\x02F7\x10\x12\x12\x06\n\x02F8\
    \x10\x13\x12\x06\n\x02F9\x10\x14\x12\x08\n\x04Home\x10\x15\x12\r\n\tLeft\
    Arrow\x10\x16\x12\x08\n\x04Meta\x10\x17\x12\n\n\x06Option\x10\x18\x12\
    \x0c\n\x08PageDown\x10\x19\x12\n\n\x06PageUp\x10\x1a\x12\n\n\x06Return\
    \x10\x1b\x12\x0e\n\nRightArrow\x10\x1c\x12\t\n\x05Shift\x10\x1d\x12\t\n\
    \x05Space\x10\x1e\x12\x07\n\x03Tab\x10\x1f\x12\x0b\n\x07UpArrow\x10\x20\
    \x12\x0b\n\x07Numpad0\x10!\x12\x0b\n\x07Numpad1\x10\"\x12\x0b\n\x07Numpa\
    d2\x10#\x12\x0b\n\x07Numpad3\x10$\x12\x0b\n\x07Numpad4\x10%\x12\x0b\n\
    \x07Numpad5\x10&\x12\x0b\n\x07Numpad6\x10'\x12\x0b\n\x07Numpad7\x10(\x12\
    \x0b\n\x07Numpad8\x10)\x12\x0b\n\x07Numpad9\x10*\x12\n\n\x06Cancel\x10+\
    \x12\t\n\x05Clear\x10,\x12\x08\n\x04Menu\x10-\x12\t\n\x05Pause\x10.\x12\
    \x08\n\x04Kana\x10/\x12\n\n\x06Hangul\x100\x12\t\n\x05Junja\x101\x12\t\n\
    \x05Final\x102\x12\t\n\x05Hanja\x103\x12\t\n\x05Kanji\x104\x12\x0b\n\x07\
    Convert\x105\x12\n\n\x06Select\x106\x12\t\n\x05Print\x107\x12\x0b\n\x07E\
    xecute\x108\x12\x0c\n\x08Snapshot\x109\x12\n\n\x06Insert\x10:\x12\x08\n\
    \x04Help\x10;\x12\t\n\x05Sleep\x10<\x12\r\n\tSeparator\x10=\x12\n\n\x06S\
    croll\x10>\x12\x0b\n\x07NumLock\x10?\x12\x08\n\x04RWin\x10@\x12\x08\n\
    \x04Apps\x10A\x12\x0c\n\x08Multiply\x10B\x12\x07\n\x03Add\x10C\x12\x0c\n\
    \x08Subtract\x10D\x12\x0b\n\x07Decimal\x10E\x12\n\n\x06Divide\x10F\x12\n\
    \n\x06Equals\x10G\x12\x0f\n\x0bNumpadEnter\x10H\x12\n\n\x06RShift\x10I\
    \x12\x0c\n\x08RControl\x10J\x12\x08\n\x04RAlt\x10K\x12\x0e\n\nCtrlAltDel\
    \x10d\x12\x0e\n\nLockScreen\x10e*F\n\x08FileType\x12\x07\n\x03Dir\x10\0\
    \x12\x0b\n\x07DirLink\x10\x02\x12\x0c\n\x08DirDrive\x10\x03\x12\x08\n\
    \x04File\x10\x04\x12\x0c\n\x08FileLink\x10\x05*;\n\x0cImageQuality\x12\n\
    \n\x06NotSet\x10\0\x12\x07\n\x03Low\x10\x02\x12\x0c\n\x08Balanced\x10\
    \x03\x12\x08\n\x04Best\x10\x04b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(62);
            messages.push(EncodedVideoFrame::generated_message_descriptor_data());
            messages.push(EncodedVideoFrames::generated_message_descriptor_data());
            messages.push(RGB::generated_message_descriptor_data());
            messages.push(YUV::generated_message_descriptor_data());
            messages.push(VideoFrame::generated_message_descriptor_data());
            messages.push(IdPk::generated_message_descriptor_data());
            messages.push(DisplayInfo::generated_message_descriptor_data());
            messages.push(PortForward::generated_message_descriptor_data());
            messages.push(FileTransfer::generated_message_descriptor_data());
            messages.push(LoginRequest::generated_message_descriptor_data());
            messages.push(ChatMessage::generated_message_descriptor_data());
            messages.push(Features::generated_message_descriptor_data());
            messages.push(SupportedEncoding::generated_message_descriptor_data());
            messages.push(PeerInfo::generated_message_descriptor_data());
            messages.push(LoginResponse::generated_message_descriptor_data());
            messages.push(MouseEvent::generated_message_descriptor_data());
            messages.push(KeyEvent::generated_message_descriptor_data());
            messages.push(CursorData::generated_message_descriptor_data());
            messages.push(CursorPosition::generated_message_descriptor_data());
            messages.push(Hash::generated_message_descriptor_data());
            messages.push(Clipboard::generated_message_descriptor_data());
            messages.push(FileEntry::generated_message_descriptor_data());
            messages.push(FileDirectory::generated_message_descriptor_data());
            messages.push(ReadDir::generated_message_descriptor_data());
            messages.push(ReadAllFiles::generated_message_descriptor_data());
            messages.push(FileAction::generated_message_descriptor_data());
            messages.push(FileTransferCancel::generated_message_descriptor_data());
            messages.push(FileResponse::generated_message_descriptor_data());
            messages.push(FileTransferDigest::generated_message_descriptor_data());
            messages.push(FileTransferBlock::generated_message_descriptor_data());
            messages.push(FileTransferError::generated_message_descriptor_data());
            messages.push(FileTransferSendRequest::generated_message_descriptor_data());
            messages.push(FileTransferSendConfirmRequest::generated_message_descriptor_data());
            messages.push(FileTransferDone::generated_message_descriptor_data());
            messages.push(FileTransferReceiveRequest::generated_message_descriptor_data());
            messages.push(FileRemoveDir::generated_message_descriptor_data());
            messages.push(FileRemoveFile::generated_message_descriptor_data());
            messages.push(FileDirCreate::generated_message_descriptor_data());
            messages.push(CliprdrMonitorReady::generated_message_descriptor_data());
            messages.push(CliprdrFormat::generated_message_descriptor_data());
            messages.push(CliprdrServerFormatList::generated_message_descriptor_data());
            messages.push(CliprdrServerFormatListResponse::generated_message_descriptor_data());
            messages.push(CliprdrServerFormatDataRequest::generated_message_descriptor_data());
            messages.push(CliprdrServerFormatDataResponse::generated_message_descriptor_data());
            messages.push(CliprdrFileContentsRequest::generated_message_descriptor_data());
            messages.push(CliprdrFileContentsResponse::generated_message_descriptor_data());
            messages.push(Cliprdr::generated_message_descriptor_data());
            messages.push(SwitchDisplay::generated_message_descriptor_data());
            messages.push(PermissionInfo::generated_message_descriptor_data());
            messages.push(VideoCodecState::generated_message_descriptor_data());
            messages.push(OptionMessage::generated_message_descriptor_data());
            messages.push(TestDelay::generated_message_descriptor_data());
            messages.push(PublicKey::generated_message_descriptor_data());
            messages.push(SignedId::generated_message_descriptor_data());
            messages.push(AudioFormat::generated_message_descriptor_data());
            messages.push(AudioFrame::generated_message_descriptor_data());
            messages.push(MessageBox::generated_message_descriptor_data());
            messages.push(BackNotification::generated_message_descriptor_data());
            messages.push(ElevationRequestWithLogon::generated_message_descriptor_data());
            messages.push(ElevationRequest::generated_message_descriptor_data());
            messages.push(Misc::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(9);
            enums.push(KeyboardMode::generated_enum_descriptor_data());
            enums.push(ControlKey::generated_enum_descriptor_data());
            enums.push(FileType::generated_enum_descriptor_data());
            enums.push(ImageQuality::generated_enum_descriptor_data());
            enums.push(permission_info::Permission::generated_enum_descriptor_data());
            enums.push(video_codec_state::PreferCodec::generated_enum_descriptor_data());
            enums.push(option_message::BoolOption::generated_enum_descriptor_data());
            enums.push(back_notification::BlockInputState::generated_enum_descriptor_data());
            enums.push(back_notification::PrivacyModeState::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
